Rprof("hi.out")
library(pkg)#
library(FastGP)#
library(MCMCpack)#
library(LaplacesDemon)#
set.seed(526113322)#
nDocs = 10#
node = 1:4#
netstat = c("dyadic")#
timestat = c("timeofday", "dayofweek")#
L = 3#
P = 6#
prior.b = list(rep(0.5, P), 0.5* diag(P))#
prior.delta = c(-5, 0.1)#
prior.eta = list(rep(2.5, length(node) + length(timestat)), 0.5*diag(length(node) +length(timestat)))#
prior.tau = 1#
sigma.Q = c(0.001, 0.0001, 0.01, 0.05)#
#
b = prior.b[[1]]#
eta = prior.eta[[1]]#
delta = prior.delta[1]#
sigma_tau = prior.tau#
support = gibbs.measure.support(length(node)-1)#
base.data = GenerateDocs(500, node, b, eta, delta, sigma_tau, support, netstat, timestat,#
                        base.data= NULL, backward = FALSE, base = TRUE) #
Outer = 1#
Inner = c(1,1,1)
Schein <- Schein(5000, nDocs, node, prior.b, prior.delta, prior.eta, prior.tau, sigma.Q, Outer, Inner,#
               netstat = c("dyadic"), timestat = c("timeofday", "dayofweek"),#
              base.data = base.data, generate_PP_plots = TRUE)
summaryRprof("hi.out")
library(pkg)#
library(FastGP)#
library(MCMCpack)#
library(LaplacesDemon)#
set.seed(526113322)#
nDocs = 10#
node = 1:4#
netstat = c("dyadic")#
timestat = c("timeofday", "dayofweek")#
L = 3#
P = 6#
prior.b = list(rep(0.5, P), 0.5* diag(P))#
prior.delta = c(-5, 0.1)#
prior.eta = list(rep(2.5, length(node) + length(timestat)), 0.5*diag(length(node) +length(timestat)))#
prior.tau = 1#
sigma.Q = c(0.001, 0.001, 0.05, 0.05)#
#
b = prior.b[[1]]#
eta = prior.eta[[1]]#
delta = prior.delta[1]#
sigma_tau = prior.tau#
support = gibbs.measure.support(length(node)-1)#
base.data = GenerateDocs(500, node, b, eta, delta, sigma_tau, support, netstat, timestat,#
                        base.data= NULL, backward = FALSE, base = TRUE) #
Outer = 1#
Inner = c(1,1,1)#
Schein <- Schein(5000, nDocs, node, prior.b, prior.delta, prior.eta, prior.tau, sigma.Q, Outer, Inner,#
               netstat = c("dyadic"), timestat = c("timeofday", "dayofweek"),#
              base.data = base.data, generate_PP_plots = TRUE)
library(pkg)#
library(FastGP)#
library(MCMCpack)#
library(LaplacesDemon)#
set.seed(526113322)#
nDocs = 10#
node = 1:4#
netstat = c("dyadic")#
timestat = c("timeofday", "dayofweek")#
L = 3#
P = 6#
prior.b = list(rep(0.5, P), 0.5* diag(P))#
prior.delta = c(-5, 0.1)#
prior.eta = list(rep(2.5, length(node) + length(timestat)), 0.5*diag(length(node) +length(timestat)))#
prior.tau = 1#
sigma.Q = c(0.001, 0.001, 0.005, 0.05)#
#
b = prior.b[[1]]#
eta = prior.eta[[1]]#
delta = prior.delta[1]#
sigma_tau = prior.tau#
support = gibbs.measure.support(length(node)-1)#
base.data = GenerateDocs(500, node, b, eta, delta, sigma_tau, support, netstat, timestat,#
                        base.data= NULL, backward = FALSE, base = TRUE) #
Outer = 1#
Inner = c(1,1,1)#
Schein <- Schein(5000, nDocs, node, prior.b, prior.delta, prior.eta, prior.tau, sigma.Q, Outer, Inner,#
               netstat = c("dyadic"), timestat = c("timeofday", "dayofweek"),#
              base.data = base.data, generate_PP_plots = TRUE)
hi = load('~/Desktop/DAME/UNdatafull.RData')
hi
names(UNdatafull)
dim(UNdatafull$Y)
head(UNdatafull$Y)
head(UNdatafull$X)
UNdatafull$X
dim(UNdatafull$X)
dimnames(UNdatafull$X)
# Generative process#
library(combinat)#
library(mvtnorm)#
library(MCMCpack)#
library(Rcpp)#
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')#
#
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, delta, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum((delta+lambda.i)*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
						x_adr = X[d, a, r, ]#
						lambda[[d]][a, r] = delta + beta %*% x_adr#
					}#
			}#
	}			#
	return(lambda)#
}  #
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		lambda = matrix(0, A, A)#
		tau = rep(0, A)#
		for (a in 1:A) {#
			for (r in c(1:A)[-a]) {#
				x_adr = X[d, a, r, ]   #now random covariates#
				lambda[a, r] = beta %*% x_adr#
			}#
			u[[d]][a, -a] = r.gibbs.measure(lambda[a, -a], delta, support) #
			y_ad = Y[d, a, ]		   #now random covariates#
			tau[a] = rlnorm(1, eta %*% y_ad, sqrt(sigma2))#
		}#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) - log(prod(exp(lambda[[d]][a, -a])+1)-1)#
    					})#
    				}))#
		for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				}))#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta)))#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta.new)))			 	  #
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta)))#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)
beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))
infer
Rprof('hi.out')
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 50#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(unlist(lapply(initial$u, function(x) rowSums(x)))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				mean(unlist(lapply(infer$u, function(x) rowSums(x)))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRprof("hi.out")
Rprof('hi.out')
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 100#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(unlist(lapply(initial$u, function(x) rowSums(x)))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				mean(unlist(lapply(infer$u, function(x) rowSums(x)))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRprof("hi.out")
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, delta, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
						x_adr = X[d, a, r, ]#
						lambda[[d]][a, r] = delta + beta %*% x_adr#
					}#
			}#
	}			#
	return(lambda)#
}  #
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		tau = rep(0, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
			y_ad = Y[d, a, ]		   #now random covariates#
			tau[a] = rlnorm(1, eta %*% y_ad, sqrt(sigma2))#
		}#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) - log(prod(exp(lambda[[d]][a, -a])+1)-1)#
    					})#
    				}))#
		for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				}))#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta)))#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta.new)))			 	  #
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta)))#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}
Rprof('hi.out')
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 100#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(unlist(lapply(initial$u, function(x) rowSums(x)))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				mean(unlist(lapply(infer$u, function(x) rowSums(x)))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
						x_adr = X[d, a, r, ]#
						lambda[[d]][a, r] = delta + beta %*% x_adr#
					}#
			}#
	}			#
	return(lambda)#
}  #
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		tau = rep(0, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
			y_ad = Y[d, a, ]		   #now random covariates#
			tau[a] = rlnorm(1, eta %*% y_ad, sqrt(sigma2))#
		}#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) - log(prod(exp(lambda[[d]][a, -a])+1)-1)#
    					})#
    				}))#
		for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				}))#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta)))#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta.new)))			 	  #
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta)))#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}
Rprof('hi.out')
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 100#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(unlist(lapply(initial$u, function(x) rowSums(x)))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				mean(unlist(lapply(infer$u, function(x) rowSums(x)))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRprof("hi.out")
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
dim(Y)
Y[1,,]
Y[1,,] %*% eta
eta
a
a = 1
Y[d, a, ] %*% eta
d = 3
Y[d, a, ] %*% eta
Y[d, a, ]
eta
eta %*% Y[d, a, ]
mu_cal = function(Y, eta) {#
	D = dim(Y)[1]#
	A = dim(Y)[2]#
	mu = matrix(0, D, A)#
	for (d in 1:D) {#
		for (a in 1:A) {#
			mu[d, a] = eta %*% Y[d, a, ] #
		}#
	}#
	return(mu)#
}
mu_cal(Y, eta)
mu = transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta)))
head(mu)
library(microbenchmark)
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
microbenchmark(transpose(sapply(1:D, function(d) Y[d, , ] %*% transpose(eta))), mu_cal(Y, eta))
eta %*% Y[d, a, ]
sum(eta*Y[d,a,])
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
microbenchmark( eta %*% Y[d, a, ]#
, sum(eta*Y[d,a,]))
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
						x_adr = X[d, a, r, ]#
						lambda[[d]][a, r] = delta + beta %*% x_adr#
					}#
			}#
	}			#
	return(lambda)#
}  #
#
mu_cal = function(Y, eta) {#
	D = dim(Y)[1]#
	A = dim(Y)[2]#
	mu = matrix(0, D, A)#
	for (d in 1:D) {#
		for (a in 1:A) {#
			mu[d, a] = eta %*% Y[d, a, ] #
		}#
	}#
	return(mu)#
}#
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		tau = rep(0, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
			y_ad = Y[d, a, ]		   #now random covariates#
			tau[a] = rlnorm(1, eta %*% y_ad, sqrt(sigma2))#
		}#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) - log(prod(exp(lambda[[d]][a, -a])+1)-1)#
    					})#
    				}))#
		for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				}))#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
        mu = mu_cal(Y, eta)#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
        	mu = mu_cal(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = mu_cal(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}
Rprof('hi.out')
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 100#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(unlist(lapply(initial$u, function(x) rowSums(x)))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				mean(unlist(lapply(infer$u, function(x) rowSums(x)))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRprof('hi.out')
unlist(lapply(initial$u, function(x) rowSums(x)))
sapply(initial$u, function(x) rowSums(x))
vapply(initial$u, function(x) rowSums(x), rep(0, A))
c(vapply(initial$u, function(x) rowSums(x), rep(0, A)))
mean(unlist(lapply(initial$u, function(x) rowSums(x))))
vapply(initial$u, function(x) rowSums(x), rep(0, A))
mean(vapply(initial$u, function(x) rowSums(x), rep(0, A)))
Rprof('hi.out')
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 100#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRprof("hi.out")
Rprof('hi.out')
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
						x_adr = X[d, a, r, ]#
						lambda[[d]][a, r] = delta + beta %*% x_adr#
					}#
			}#
	}			#
	return(lambda)#
}  #
#
mu_cal = function(Y, eta) {#
	D = dim(Y)[1]#
	A = dim(Y)[2]#
	mu = matrix(0, D, A)#
	for (d in 1:D) {#
		for (a in 1:A) {#
			mu[d, a] = eta %*% Y[d, a, ] #
		}#
	}#
	return(mu)#
}#
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		tau = rep(0, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
			y_ad = Y[d, a, ]		   #now random covariates#
			tau[a] = rlnorm(1, eta %*% y_ad, sqrt(sigma2))#
		}#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) - log(prod(exp(lambda[[d]][a, -a])+1)-1)#
    					})#
    				}))#
		for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				}))#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
        mu = mu_cal(Y, eta)#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
        	mu = mu_cal(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = mu_cal(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}#
#
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 50#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRpof("hi.out")
summaryRprof("hi.out")
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
						x_adr = X[d, a, r, ]#
						lambda[[d]][a, r] = delta + beta %*% x_adr#
					}#
			}#
	}			#
	return(lambda)#
}  #
#
mu_cal = function(Y, eta) {#
	D = dim(Y)[1]#
	A = dim(Y)[2]#
	mu = matrix(0, D, A)#
	for (d in 1:D) {#
		for (a in 1:A) {#
			mu[d, a] = eta %*% Y[d, a, ] #
		}#
	}#
	return(mu)#
}#
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		tau = rep(0, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
			y_ad = Y[d, a, ]		   #now random covariates#
			tau[a] = rlnorm(1, eta %*% y_ad, sqrt(sigma2))#
		}#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) - log(prod(exp(lambda[[d]][a, -a])+1)-1)#
    					})#
    				}))#
		for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				}))#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
        mu = mu_cal(Y, eta)#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
        	mu = mu_cal(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = mu_cal(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}#
#
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 100#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRprof("hi.out")
permn
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) #
    					})#
    				}))
lambda = lambda_cal(X, beta, delta)
sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) #
    					})#
    				}))
for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}
u = initial$u
for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}
sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) #
    					})#
    				}))
Edgepartsum(lambda, u)
microbenchmark(sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,] * u[[d]][a,]) #
    					})#
    				})), Edgepartsum(lambda, u))
lambda[[d]]
exp(lambda[[d]])
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				}))
Edgepartsum(lambda, u)
microbenchmark(sum(sapply(1:D, function(d) {#
    					sapply(1:A, function(a) {#
    					sum(lambda[[d]][a,]*u[[d]][a,]) - log(prod(exp(lambda[[d]][a,-a])+1)-1)#
    					})#
    				})), Edgepartsum(lambda, u))
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
						x_adr = X[d, a, r, ]#
						lambda[[d]][a, r] = delta + beta %*% x_adr#
					}#
			}#
	}			#
	return(lambda)#
}  #
#
mu_cal = function(Y, eta) {#
	D = dim(Y)[1]#
	A = dim(Y)[2]#
	mu = matrix(0, D, A)#
	for (d in 1:D) {#
		for (a in 1:A) {#
			mu[d, a] = eta %*% Y[d, a, ] #
		}#
	}#
	return(mu)#
}#
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	mu = mu_cal(Y, eta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
		}#
		tau = rlnorm(A, mu[d, ], sqrt(sigma2))#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
        mu = mu_cal(Y, eta)#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
        	mu = mu_cal(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = mu_cal(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}
Rprof("hi.out")
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 100#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}
summaryRprof("hi.out")
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 1000#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}#
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
D = 100#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 1000#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}#
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
n
par(mfrow=c(2,6))#
GiR_PP_Plots(result[1:468,c(1:(3+P+Q))], result[1:468,c((4+P+Q):(2*(3+P+Q)))])
hist(rinvgamma(1000, 5, 1))
Q
D = 100#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 3, b = 1)#
Nsamp = 1000#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}#
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
n
par(mfrow=c(2,6))#
GiR_PP_Plots(result[1:82,c(1:(3+P+Q))], result[1:82,c((4+P+Q):(2*(3+P+Q)))])
hist(rinvgamma(1000, 5, 1))
hist(rinvgamma(1000, 3, 1))
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
mu_cal = function(Y, eta) {#
	D = dim(Y)[1]#
	A = dim(Y)[2]#
	mu = matrix(0, D, A)#
	for (d in 1:D) {#
		for (a in 1:A) {#
			mu[d, a] = eta %*% Y[d, a, ] #
		}#
	}#
	return(mu)#
}
mu_cal(Y, eta)
hey1 = mu_cal(Y, eta)
hey2 = mu_cpp(Y, eta)
eta
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
hey2 = mu_cpp(Y, eta)
identical(hey1, hey2)
head(hey1)
head(hey2)
microbenchmark( mu_cal(Y, eta),mu_cpp(Y, eta) )
# Generative process#
library(combinat)#
library(mvtnorm)#
library(MCMCpack)#
library(Rcpp)#
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')#
#
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = matrix(0, A, A)#
		for (a in 1:A) {#
			for (r in c(1:A)[-a]) {#
					x_adr = X[d, a, r, ]#
					lambda[[d]][a, r] = delta + beta %*% x_adr#
				}#
		}#
	}			#
	return(lambda)#
}  #
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	mu = mu_cpp(Y, eta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
		}#
		tau = rlnorm(A, mu[d, ], sqrt(sigma2))#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
        mu = mu_cpp(Y, eta)#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
        	mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}#
#
D = 30#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 3, b = 1)#
Nsamp = 2500#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}#
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
nn
n
par(mfrow=c(2,6))#
GiR_PP_Plots(result[1:2192,c(1:(3+P+Q))], result[1:2192,c((4+P+Q):(2*(3+P+Q)))])
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
lambda = lambda_cal(X, beta, delta)
lambda2 = lambda_cpp(X, beta, delta)
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = lambda_cpp(X[d,,], beta, delta)#
	}			#
	return(lambda)#
}
lambda2 = lambda_cal(X, beta, delta)
D = dim(X)[1]#
	A = dim(X)[2]
D
dim(X)
dim(X[d,,])
dim(X[d,,,])
d
d = 3
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = lambda_cpp(X[d,,,], beta, delta)#
	}			#
	return(lambda)#
}
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = lambda_cpp(X[d,,,], beta, delta)#
	}			#
	return(lambda)#
}
lambda2 = lambda_cal(X, beta, delta)
head(lambda1)
head(lambda)
head(lambda2)
beta
delta
lambda_cpp(X[d,,,], beta, delta)
X[d,,,]
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = lambda_cpp(X[d,,,], beta, delta)#
	}			#
	return(lambda)#
}  #
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	mu = mu_cpp(Y, eta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
		}#
		tau = rlnorm(A, mu[d, ], sqrt(sigma2))#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
        mu = mu_cpp(Y, eta)#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
        	mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}#
#
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)
dim(X)
lambda = lambda_cal(X, beta, delta)
lambda
dim(X)
class(X[1,,,])
D = dim(X)[1]#
	A = dim(X)[2]
D
A
d = 1
lambda_cpp(X[d,,,], beta, delta)
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
lambda_cpp(X[d,,,], beta, delta)
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')
lambda_cpp(X[d,,,], beta, delta)
# Generative process#
library(combinat)#
library(mvtnorm)#
library(MCMCpack)#
library(Rcpp)#
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/GiR/Multicast_rcpp.cpp')#
#
gibbs.measure.support = function(n) {#
	gibbs.support = rbind(rep(1, n))#
	for(i in 1:(n-1)){#
		gibbs.mat.i = do.call('rbind',permn(c(rep(1, i), rep(0, n-i))))#
		gibbs.support = rbind(gibbs.support, gibbs.mat.i)#
	}#
	out = as.matrix(unique(gibbs.support))#
	return(out)#
}#
#
r.gibbs.measure <- function(lambda.i, support) {#
	#gibbsNormalizer = prod(exp(delta+lambda.i)+1)-1#
	logitNumerator = vapply(1:nrow(support), function(s) {#
		sum(lambda.i*support[s,])#
		}, c(1))		#
	samp = multinom_vec(exp(logitNumerator))#
	return(support[samp,])	#
}#
#
dinvgamma = function(x, shape, scale) {#
    alpha <- shape#
    beta <- scale#
    log.density <- alpha * log(beta) - lgamma(alpha) - (alpha + #
        1) * log(x) - (beta/x)#
    return(log.density)#
}#
#
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}      #
lambda_cal = function(X, beta, delta) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	lambda = list()#
	for (d in 1:D) {#
		lambda[[d]] = lambda_cpp(X[d,,,], beta, delta)#
	}			#
	return(lambda)#
}  #
Generate = function(D, A, beta, delta, eta, sigma2, X, Y, support, timeunit = 3600) {#
	P = length(beta)#
	Q = length(eta)#
	u = list()#
	data = list()#
	t_d = 0#
	lambda = lambda_cal(X, beta, delta)#
	mu = mu_cpp(Y, eta)#
	for (d in 1:D) {#
		u[[d]] = matrix(0, A, A)#
		for (a in 1:A) {#
			u[[d]][a, -a] = r.gibbs.measure(lambda[[d]][a, -a], support) #
		}#
		tau = rlnorm(A, mu[d, ], sqrt(sigma2))#
		a_d = which(tau == min(tau))#
		r_d = u[[d]][a_d,]#
		t_d = t_d + min(tau) * timeunit#
		data[[d]] = list(a_d = a_d, r_d = r_d, t_d = t_d)#
	}#
	return(list(data = data, u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2, X = X, Y = Y))#
}#
#
Inference = function(data, outer, inner, prior.beta, prior.delta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600) {#
	u = initial$u#
	beta = initial$beta#
	delta = initial$delta#
	eta = initial$eta#
	sigma2 = initial$sigma2#
	X = initial$X#
	Y = initial$Y#
	D = length(u)#
	P = length(beta)#
	Q = length(eta)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1], timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	for (o in 1:outer) {#
		lambda = lambda_cal(X, beta, delta)#
		for (d in 1:D) {#
			for (a in 1:A) {#
				for (r in c(1:A)[-a]) {#
					prob = c(as.numeric(sum(u[[d]][a,-r]) > 0), exp(lambda[[d]][a, r]))#
					u[[d]][a, r] = multinom_vec(prob)-1#
				}#
			}#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var) +#
					dnorm(delta, prior.delta$mean, prior.delta$var, log = TRUE)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
			delta.new = rnorm(1, delta, proposal.var[2])#
      		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var) +#
      					dnorm(delta.new, prior.delta$mean, prior.delta$var, log = TRUE)#
			lambda = lambda_cal(X, beta.new, delta.new)#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			delta = delta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
        mu = mu_cpp(Y, eta)#
    	post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[3]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
        	mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
        mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[4]))#
      		prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}		#
	}#
	return(list(u = u, beta = beta, delta = delta, eta = eta, sigma2 = sigma2))#
}#
#
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 2500#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 10, c(10,5,10), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}#
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
n
par(mfrow=c(2,6))#
GiR_PP_Plots(result[1:5,c(1:(3+P+Q))], result[1:5,c((4+P+Q):(2*(3+P+Q)))])
par(mfrow=c(2,6))#
GiR_PP_Plots(result[1:673,c(1:(3+P+Q))], result[1:673,c((4+P+Q):(2*(3+P+Q)))])
head(result)
result = result[1:673,]
sum(result[,20]==result[,10])
sum(result[,19]==result[,9])
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 5, b = 1)#
Nsamp = 2500#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 5, c(5,5,5), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}#
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
D = 50#
A = 5#
P = 4#
Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = rep(0, P), var = diag(P))#
prior.delta = list(mean = rep(0, 1), var = diag(1))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 4, b = 1)#
Nsamp = 2500#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
	beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
	delta = rnorm(1, prior.delta$mean, prior.delta$var)#
	eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
	sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
	initial = Generate(D, A, beta, delta, eta, sigma2, X, Y, support)#
	infer = Inference(initial$data, 5, c(5,5,5), prior.beta, prior.delta, prior.eta, prior.sigma2, initial,#
		  proposal.var = c(0.1, 0.1, 0.01, 0.1))#
	result[n, ] = c(mean(vapply(initial$u, function(x) rowSums(x), rep(0, A))),#
				initial$beta, initial$delta, initial$eta, initial$sigma2, #
				 mean(vapply(infer$u, function(x) rowSums(x), rep(0, A))),#
				infer$beta, infer$delta, infer$eta, infer$sigma2)#
}#
par(mfrow=c(2,6))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
