Montgomery_PPC
for (n in 1:71) {#
	filename = paste0("Montgomery_PPC", n,".RData")#
	load(filename)#
	indegreedist[n, ] = tabulate(vapply(1:621, function(x) Montgomery_PPC[[x]]$a_d, c(1)), A)#
	outdegreedist[n, ] = rowSums(sapply(1:621, function(x) Montgomery_PPC[[x]]$r_d))#
	recipientsdist[n, ] = tabulate(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$r_d), c(1)), A-1)#
}
A
n
indegreedist
indegreedist = matrix(NA, 71, A)#
outdegreedist = matrix(NA, 71, A)#
recipientsdist = matrix(NA, 71, A-1)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code")#
for (n in 1:71) {#
	filename = paste0("Montgomery_PPC", n,".RData")#
	load(filename)#
	indegreedist[n, ] = tabulate(vapply(1:621, function(x) Montgomery_PPC[[x]]$a_d, c(1)), A)#
	outdegreedist[n, ] = rowSums(sapply(1:621, function(x) Montgomery_PPC[[x]]$r_d))#
	recipientsdist[n, ] = tabulate(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$r_d), c(1)), A-1)#
}
par(mfrow = c(3,1))#
#
boxplot(indegreedist)#
lines(indegree, col = 2)#
#
boxplot(outdegreedist)#
lines(outdegree, col = 2)#
#
boxplot(recipientsdist)#
lines(recipients, col = 2)
indegreedist
tabulte(indegreedist)
tabulate(indegreedist)
summary(indegreedist)
summary(c(indegreedist))
boxplot(recipientsdist)
lines(recipients, col = 2)
recipientsdist
recipients
boxplot(recipientsdist)#
lines(recipients, col = 2)
indegree = rep(0, 3)
timeunit = 3600#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
#
indegree = tabulate(email[trim,2], A)#
outdegree = colSums(email[trim,3:20])#
recipients = tabulate(rowSums(email[trim,3:20]), A-1)#
timeinc = diff(email$timepoints[21:max(trim)])#
indegreedist = matrix(NA, 71, A)#
outdegreedist = matrix(NA, 71, A)#
recipientsdist = matrix(NA, 71, A-1)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code")#
for (n in 1:71) {#
	filename = paste0("Montgomery_PPC", n,".RData")#
	load(filename)#
	indegreedist[n, ] = tabulate(vapply(1:621, function(x) Montgomery_PPC[[x]]$a_d, c(1)), A)#
	outdegreedist[n, ] = rowSums(sapply(1:621, function(x) Montgomery_PPC[[x]]$r_d))#
	recipientsdist[n, ] = tabulate(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$r_d), c(1)), A-1)#
} #
#
par(mfrow = c(3,1))
boxplot(indegreedist)#
lines(indegree, col = 2)#
#
boxplot(outdegreedist)#
lines(outdegree, col = 2)#
#
boxplot(recipientsdist)#
lines(recipients, col = 2)
boxplot(recipientsdist)#
lines(recipients, col = 2)
recipients
sum(recipients)
trim
max(trim)
timeinc = diff(email$timepoints[43:max(trim)])
timeinc
length(timeinc)
timeinc = diff(email$timepoints[42:max(trim)])
indegreesum = rep(0, 3)
table(c(indegreedist))
indegreesum = table(floor(c(indegreedist))/10 +1)
indegreesum
indegreesum = table(floor(c(indegreedist)/10) +1)
indegreesum
indegreesum = table(floor(c(indegreedist)/10))
indegreesum
boxplot(indegreesum)
indegreesum = table(floor(indegreedist/10))
indegreesum
indegreedist/10
floor(indegreedist/10)
boxplot(floor(indegreedist/10))
boxplot(recipientsdist)
lines(recipients, col = 2)
boxplot(indegreedist)#
lines(indegree, col = 2)
indegree
boxplot(indegreedist)
boxplot(outdegreedist)
lines(outdegree, col = 2)
boxplot(indegreedist)
lines(indegree, col = 2)
indegree
sum(indegree)
indegree = tabulate(email[trim,2], A)
email
indegreedist = matrix(NA, 71, A)#
outdegreedist = matrix(NA, 71, A)#
recipientsdist = matrix(NA, 71, A-1)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code")#
for (n in 1:71) {#
	filename = paste0("Montgomery_PPC", n,".RData")#
	load(filename)#
	outdegreedist[n, ] = tabulate(vapply(1:621, function(x) Montgomery_PPC[[x]]$a_d, c(1)), A)#
	indegreedist[n, ] = rowSums(sapply(1:621, function(x) Montgomery_PPC[[x]]$r_d))#
	recipientsdist[n, ] = tabulate(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$r_d), c(1)), A-1)#
}
boxplot(indegreedist)#
lines(indegree, col = 2)
boxplot(outdegreedist)#
lines(outdegree, col = 2)
boxplot(indegreedist)#
lines(indegree, col = 2)
indegree
sum(indegree)
boxplot(outdegreedist)#
lines(outdegree, col = 2)
boxplot(recipientsdist)#
lines(recipients, col = 2)
diff(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$t_d), c(1)))
Montgomery_PPC[[x]]$t_d
vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$t_d), c(1))
diff(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$t_d), c(1)))
email$timepoints[42]
c(email$timepoints[42], diff(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$t_d), c(1)))) / timeunit
indegreedist = matrix(NA, 71, A)#
outdegreedist = matrix(NA, 71, A)#
recipientsdist = matrix(NA, 71, A-1)#
timedist = matrix(NA, 71, 621)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code")#
for (n in 1:71) {#
	filename = paste0("Montgomery_PPC", n,".RData")#
	load(filename)#
	outdegreedist[n, ] = tabulate(vapply(1:621, function(x) Montgomery_PPC[[x]]$a_d, c(1)), A)#
	indegreedist[n, ] = rowSums(sapply(1:621, function(x) Montgomery_PPC[[x]]$r_d))#
	recipientsdist[n, ] = tabulate(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$r_d), c(1)), A-1)#
	timedist[n, ] = c(email$timepoints[42], diff(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$t_d), c(1)))) / timeunit#
}
boxplot(timedist)
plot(timedist)
head(timedist)
plot(c(timedist[,-1]), timeinc[-1])
qqplot(c(timedist[,-1]), timeinc[-1])
timeinc[-1]
timeinc = diff(email$timepoints[42:max(trim)])
timeinc
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))
email$timepoints
n
timeinc = diff(sort(email$timepoints)[42:max(trim)])
timeinc
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
A = length(Montgomery$manager_gender)
email$timepoints
sort(email$timepoints)
timeinc = diff(sort(email$timepoints)[42:max(trim)])
timeinc
timeinc = diff(sort(email$timepoints)[42:max(trim)])/3600
timeinc
qqplot(c(timedist[,-1]), timeinc[-1])
timeinc
length(timeinc)
timeinc = diff(sort(email$timepoints)[43:max(trim)])/3600
qqplot(c(timedist[,-1]), timeinc)
abline(0, 1, col = 2)
GiR_PP_Plots(c(timedist[,-1]), timeinc)
library(quanlityTools)
library(CircStats)
pp.plot(c(timedist[,-1]))
c(timedist[,-1])
timedist[,-1]
hist(timedist[,2])
boxplot(timedist[,1])
boxplot(timedist[,-1])
lines(timeinc, col = 2)
boxplot(timedist[,-1], ylim = c(0, 1000))
lines(timeinc, col = 2)
timeinc
plot(timeinc)
boxplot(timedist[,-1], ylim = c(0, 1000))#
lines(timeinc, col = 2)
boxplot(timedist[,-1], ylim = c(0, 100))#
lines(timeinc, col = 2)
boxplot(timedist[,-1], ylim = c(0, 80))
lines(timeinc, col = 2)
Montgomery_PPC[[1]]
boxplot(outdegreedist)#
lines(outdegree, col = 2)
outdegree
boxplot(outdegreedist, ylim = c(0, 200))#
lines(outdegree, col = 2)
boxplot(outdegreedist, ylim = c(0, 300))#
lines(outdegree, col = 2)
node
Montgomery$manager_gender
Montgomery$manager_department
boxplot(outdegreedist, ylim = c(0, 275))
lines(outdegree, col = 2)
boxplot(outdegreedist, ylim = c(0, 275), main = "outdegree")#
lines(outdegree, col = 2)
boxplot(indegreedist)#
lines(indegree, col = 2)
indegree
boxplot(indegreedist)
boxplot(indegreedist, main = "indegree")#
lines(indegree, col = 2, ylim = c(0, 200))
boxplot(indegreedist,ylim = c(0, 200),  main = "indegree")
lines(indegree, col = 2)
boxplot(indegreedist,ylim = c(0, 170),  main = "indegree")
lines(indegree, col = 2)
boxplot(recipientsdist)#
lines(recipients, col = 2)
recipients
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")#
lines(recipients, col = 2)
head(timedist)
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))
uniqueValues
qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)
qqplot(c(timedist[,-1]), timeinc)
hi = quantile(c(timedist[,-1]), c(.05, .95 ))
qqplot(hi, timeinc)
hi
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc)
abline(0, 1, col = 2)
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc, xlab = "post", ylab = "obs")
abline(0, 1, col = 2)
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))#
  qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)
hi = quantile(c(timedist[,-1]), c(.05, .95 ))#
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc, xlab = "post", ylab = "obs")#
abline(0, 1, col = 2)
hi = quantile(c(timedist[,-1]), c(.05, .95 ))#
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc, xlab = "post", ylab = "obs", main = "timeinc")#
abline(0, 1, col = 2)
# Generative process#
library(combinat)#
library(mvtnorm)#
library(MCMCpack)#
library(Rcpp)#
library(lubridate)#
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast_rcpp.cpp')
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 9#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10		#
		}#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 0.1*dim(Y)[1], replace = FALSE), ] = 1
missing
dim(Y)[1]
0.1*dim(Y)[1]
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing
sum(missing[[1]]==1 & missing[[3]]==1)
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)
missing[[2]]
0.1*(dim(Y)[1]*A)
missing[[2]][sample(1:(dim(Y)[1]*A), 0.1*(dim(Y)[1]*A), replace = FALSE)] = 1
missing[[2]]
rowSums(missing[[2]])
sum(missing[[2]])
0.1*(dim(Y)[1]*A)
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)#
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing[[2]]
which(rowSums(missing[[2]])>0)
edge[[1]]
edge[[1]][[2]]
edge[[1]][[2]][which(missing[[2]][d,]==1)]
d
d = 1
edge[[1]][[2]][which(missing[[2]][d,]==1)]
d
d = 2
edge[[1]][[2]][which(missing[[2]][d,]==1)]
u[[d]][sender[d], which(missing[[2]][d,]==1)]
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")
names(Montgomery_infer)
Montgomery_infer$u[[1]]
length(Montgomery_infer$u)
Montgomery_infer$u[[d]][sender[d], which(missing[[2]][d,]==1)]
Montgomery_infer$u[[d]][1, which(missing[[2]][d,]==1)]
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")
PPE
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
dlnorm(mu[d,], sigma_tau, timeinc[d])
dlnorm
dlnorm(10, rnorm(5), 1)
mean = c(1,2,3,4,5)
dlnorm(10, mean, 1)
dlnorm(10, 1, 1)
dlnorm(10, 2, 1)
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast_rcpp.cpp')
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        senders[d] = rmultinom(1, 1, probi)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, sender[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][sender[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
warnings()
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        browser()#
        senders[d] = rmultinom(1, 1, probi)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, sender[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][sender[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
probi
rmultinom(1, 1, probi)
which(rmultinom(1, 1, probi)==1)
Q
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        senders[d] = which(rmultinom(1, 1, probi)==1)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, sender[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][sender[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        senders[d] = which(rmultinom(1, 1, probi)==1)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, senders[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][senders[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
exp(-0.4)
exp(-3.5)
recipients = tabulate(rowSums(email[trim,3:20]), A-1)
recipients
recipients = table(rowSums(email[trim,3:20]))
recipients
Montgomery_infer$department
names(Montgomery)
Montgomery$manager_department
hello = rowSums(email[trim,3:20])
which(hello >=10)
senders[which(hello >=10)]
senders = email[,2]
senders
senders[which(hello >=10)]
table(senders)
senders[which(hello >=8)]
load("/Users/bomin8319/Desktop/Montgomery_infer.RData")
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 11#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] > 0, sum(X[d,a,,4]), 0)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
getwd()
initial = list()#
initial$sender = email[1:(min(trim)-1), 2]#
initial$receiver = email[1:(min(trim)-1), 3:20]#
initial$time = email[1:(min(trim)-1),1]#
for (n in 1:500) {#
  Montgomery_PPC = PPC(length(edge), A, colMeans(Montgomery_infer$beta), colMeans(Montgomery_infer$eta), #
                       mean(Montgomery_infer$sigma2), X, Y, timeunit = 3600, lasttime = email[min(trim-1), 21], #
                       Montgomery_infer$u, initial =initial)#
  filename = paste0("Montgomery_PPCnew", n,".RData")#
  save(Montgomery_PPC, file = filename)#
}
set.seed(1)#
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)#
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code/PPE")#
Montgomery_PPE = list()#
for (n in 1:20) {#
	print(n)#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
P
Q
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code/PPE")#
Montgomery_PPE = list()#
for (n in 1:500) {#
	print(n)#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code/PPE")#
Montgomery_PPE = list()#
for (n in 1:500) {#
	print(n)#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
load('~/Desktop/Montgomery_infer.RData')
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code/PPE")#
Montgomery_PPE = list()#
for (n in 1:500) {#
	print(n)#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
inifial$beta
initial$beta
load('~/Desktop/Montgomery_infer.RData')
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code/PPE")#
Montgomery_PPE = list()#
for (n in 1:500) {#
	print(n)#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
