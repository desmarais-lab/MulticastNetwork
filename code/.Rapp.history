recipients = tabulate(rowSums(email[trim,3:20]), A-1)
recipients
recipients = table(rowSums(email[trim,3:20]))
recipients
Montgomery_infer$department
names(Montgomery)
Montgomery$manager_department
hello = rowSums(email[trim,3:20])
which(hello >=10)
senders[which(hello >=10)]
senders = email[,2]
senders
senders[which(hello >=10)]
table(senders)
senders[which(hello >=8)]
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
A = length(Montgomery$manager_gender)#
#
#observed statistics#
timeunit = 3600#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
#
outdegree = tabulate(email[trim,2], A)#
indegree = colSums(email[trim,3:20])#
recipients = tabulate(rowSums(email[trim,3:20]), A-1)#
timeinc = diff(sort(email$timepoints)[43:max(trim)])/3600
indegreedist = matrix(NA, 500, A)#
outdegreedist = matrix(NA,  500, A)#
recipientsdist = matrix(NA,  500, A-1)#
timedist = matrix(NA, 500, 621)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code")#
for (n in 1:500) {#
	filename = paste0("Montgomery_PPCnew", n,".RData")#
	load(filename)#
	outdegreedist[n, ] = tabulate(vapply(1:621, function(x) Montgomery_PPC[[x]]$a_d, c(1)), A)#
	indegreedist[n, ] = rowSums(sapply(1:621, function(x) Montgomery_PPC[[x]]$r_d))#
	recipientsdist[n, ] = tabulate(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$r_d), c(1)), A-1)#
	timedist[n, ] = c(email$timepoints[42], diff(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$t_d), c(1)))) / timeunit#
}
par(mfrow = c(3,1))#
#
# indegreesum = table(floor(indegreedist/10))#
# boxplot(floor(indegreedist/10))#
#
boxplot(outdegreedist, ylim = c(0, 175), main = "outdegree")#
lines(outdegree, col = 2)#
#
boxplot(indegreedist,ylim = c(0, 275),  main = "indegree")#
lines(indegree, col = 2)#
#
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")#
lines(recipients, col = 2)
par(mfrow = c(1,1))
boxplot(outdegreedist, ylim = c(0, 175), main = "outdegree")#
lines(outdegree, col = 2)
boxplot(indegreedist,ylim = c(0, 275),  main = "indegree")#
lines(indegree, col = 2)
boxplot(outdegreedist, ylim = c(0, 175), main = "outdegree")#
lines(outdegree, col = 2)
boxplot(indegreedist,ylim = c(0, 275),  main = "indegree")#
lines(indegree, col = 2)
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")#
lines(recipients, col = 2)
hi = quantile(c(timedist[,-1]), c(.025, .975 ))#
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc, xlab = "post", ylab = "obs", main = "timeinc")#
abline(0, 1, col = 2)#
#
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))#
  qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}
hi = quantile(c(timedist[,-1]), c(.025, .975 ))#
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc, xlab = "post", ylab = "obs", main = "timeinc")#
abline(0, 1, col = 2)#
#
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))#
  qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))#
  qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")#
lines(recipients, col = 2)
boxplot(recipientsdist[,-c(1:3)], ylim = c(0, 515),  main = "receiver size")#
lines(recipients[-c(1:3)], col = 2)
boxplot(recipientsdist[,-c(1:3)], ylim = c(0, 10),  main = "receiver size")#
lines(recipients[-c(1:3)], col = 2)
recipients
colMeans(recipientsdist)
length(colMeans(recipientsdist))
head(recipientsdist)
length(recipients)
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")
lines(recipients, col = 2)
boxplot(recipientsdist[,1:14], ylim = c(0, 515),  main = "receiver size")
lines(recipients[1:14], col = 2)
boxplot(recipientsdist[,1:14], ylim = c(0, 515),  main = "receiver size")#
lines(recipients[1:14], col = 2)
load('~/Desktop/Montgomery_infer.RData')
names(Montgomery_infer)
boxplot(recipientsdist[,1:14], ylim = c(0, 515),  main = "receiver size")#
lines(recipients[1:14], col = 2)
boxplot(recipientsdist[,-c(1:3)], ylim = c(0, 10),  main = "receiver size")#
lines(recipients[-c(1:3)], col = 2)
colMeans(Montgomery_infer$beta)
plot(Montgomery_infer$beta[,10], type = 'l')
plot(Montgomery_infer$beta[,11], type = 'l')
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 11#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] > 0, sum(X[d,a,,4]), 0)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
dimnames(X)[[4]] = c("intercept", "outdegree", "indegree", "send", "receive", "2send", "2receive", "sibling", "cosibling", "Nreceive", "outdegree*Nrecieve")#
dimnames(Y)[[3]] = c("intercept", "female", "manager", "outdegree", "indegree", "weekend", "pm")
dimnames(Y)
save(Montgomery, file = "Montgomery.RData")
Montgomery = list(edge = edge, X = X, Y = Y, lasttime = email[min(trim-1), 21] - initialtime )
save(Montgomery, file = "Montgomery.RData")
getwd()
#install the package from Github#
library(devtools)#
install_github("desmarais-lab/MulticastNetwork/pkg")#
library(MulticastNetwork)#
#load our Montgomery county email data#
load("/Users/bomin8319/Box/gainlab_example/Bomin/Montgomery.RData")#
names(Montgomery)#
#
#data including sender a_d, reciever vector r_d, timestamp t_d#
edge = Montgomery$edge#
head(edge)#
#
#covariates affecting "who sends to whom"#
X = Montgomery$X#
head(X[100, 1, , ])#
X = X[,,,c(1:5)]    #use few covariates for this application#
#
#covariates affecting "when to send"#
Y = Montgomery$Y#
head(Y[100, , ])
Y = Y[,,,c(1:5)]    #use few covariates for this application#
P = dim(X)[4]#
Q = dim(Y)[3]
P
Q
Y = Y[,,c(1:5)]    #use few covariates for this application
Q = dim(Y)[3]
Q
prior.beta = list(mean = rep(0, P), var = 2*diag(P))#
prior.eta = list(mean = rep(0, Q), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
#
outer = 100#
inner = c(1, 1, 1)#
burn = 0#
#
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")#
names(Montgomery_infer)
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")
Inference
library(MulticastNetwork)
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")
install_github("desmarais-lab/MulticastNetwork/pkg")
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")
library(MulticastNetwork)#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 11#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] > 0, sum(X[d,a,,4]), 0)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
Montgomery_infer = Inference(edge, X, Y, 55000, c(10,1,1), 15000, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.00001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, timedist = "lognormal")
Montgomery_infer = Inference(edge, X, Y, 55000, c(10,1,1), 15000, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.00001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, timedist = "exponential")
plot(Montgomery_infer$loglike, type = 'l')
plot(Montgomery_infer$sigma2, type = 'l')
plot(Montgomery_infer$beta[,1], type = 'l')
plot(Montgomery_infer$beta[,2], type = 'l')
plot(Montgomery_infer$beta[,3], type = 'l')
plot(Montgomery_infer$beta[,4], type = 'l')
plot(Montgomery_infer$beta[,5], type = 'l')
plot(Montgomery_infer$beta[,6], type = 'l')
plot(Montgomery_infer$beta[,7], type = 'l')
plot(Montgomery_infer$beta[,8], type = 'l')
plot(Montgomery_infer$beta[,9], type = 'l')
plot(Montgomery_infer$beta[,10], type = 'l')
plot(Montgomery_infer$beta[,11], type = 'l')
plot(Montgomery_infer$eta[,1], type = 'l')
plot(Montgomery_infer$eta[,2], type = 'l')
plot(Montgomery_infer$eta[,3], type = 'l')
plot(Montgomery_infer$eta[,4], type = 'l')
plot(Montgomery_infer$eta[,5], type = 'l')
plot(Montgomery_infer$eta[,6], type = 'l')
plot(Montgomery_infer$eta[,7], type = 'l')
plot(Montgomery_infer$eta[,8], type = 'l')
Montgomery_infer2 = Montgomery_infer
save(Montgomery_infer2, file = '/Users/bomin8319/Desktop/Montgomery_infer2.RData')
library(MulticastNetwork)#
load("/Users/bomin8319/Box/gainlab_example/Bomin/Montgomery.RData")#
edge = Montgomery$edge#
X = Montgomery$X#
Y = Montgomery$Y#
P = dim(X)[4]#
Q = dim(Y)[3]#
A = dim(Y)[2]#
#
#run inference to estimate beta, eta, u, and sigma2#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
#
outer = 500#
inner = c(1, 1, 1)#
burn = 0
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}
uniqtime = unique(email$timepoints)
load('~/Desktop/MulticastNetwork/Montgomery_infer2.RData')
Montgomery_PPC = PPC(length(edge), beta = colMeans(Montgomery_infer2$beta), eta = colMeans(Montgomery_infer2$eta), #
                     sigma2 = mean(Montgomery_infer2$sigma2), X, Y, timeunit = 3600, u = Montgomery_infer2$u, timedist = "exponential")
d
rm(list=ls())
#source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
#
library(MulticastNetwork)#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 11#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] > 0, sum(X[d,a,,4]), 0)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
library(devtools)
library(MulticastNetwork)#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}
library(MulticastNetwork)#
load("/Users/bomin8319/Box/gainlab_example/Bomin/Montgomery.RData")#
edge = Montgomery$edge#
X = Montgomery$X#
Y = Montgomery$Y#
P = dim(X)[4]#
Q = dim(Y)[3]#
A = dim(Y)[2]
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)
Montgomery_infer2 = Inference(edge, X, Y, 55000, c(10,1,1), 15000, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
proposal.var = c(0.00001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, timedist = "exponential")
names(Montgomery)
Montgomery$lasttime
Montgomery_infer2 = Inference(edge, X, Y, 55000, c(10,1,1), 15000, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
proposal.var = c(0.00001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "exponential")
names(Montgomery_infer2)
plot(Montgomery_infer2$loglike, type = 'l')
plot(Montgomery_infer2$beta[1,], type = 'l')
plot(Montgomery_infer2$beta[,1], type = 'l')
plot(Montgomery_infer2$beta[,2], type = 'l')
plot(Montgomery_infer2$beta[,3], type = 'l')
plot(Montgomery_infer2$beta[,4], type = 'l')
plot(Montgomery_infer2$beta[,5], type = 'l')
plot(Montgomery_infer2$eta[,5], type = 'l')
plot(Montgomery_infer2$eta[,1], type = 'l')
plot(Montgomery_infer2$eta[,2], type = 'l')
colMeans(Montgomery_infer2$eta)
colMeans(Montgomery_infer$eta)
save(Montgomery_infer2, file = "/Users/bomin8319/Desktop.Montgomery_infer2.RData")
save(Montgomery_infer2, file = "/Users/bomin8319/Desktop//Montgomery_infer2.RData")
save(Montgomery_infer2, file = "/Users/bomin8319/Desktop/Montgomery_infer2.RData")
load('~/Desktop/MulticastNetwork/Montgomery_infer2.RData')
colMeans(Montgomery_infer$eta)
colMeans(Montgomery_infer2$eta)
load('~/Desktop/MulticastNetwork/Montgomery_infer.RData')
colMeans(Montgomery_infer$eta)
Inference
plot(Montgomery_infer2$eta[,1], type = 'l')
plot(Montgomery_infer$eta[,1], type = 'l')
rlnorm(1, 0, 1)
rexp(1, )
rexp(1, 1)
rexp(1, -1)
rexp(1, exp(-1))
rlnorm(1, -100, 1)
rexp(1, exp(-100))
rexp(1, 1/exp(-100))
mean(rexp(100, 1/exp(-100)))
mean(rexp(100, 1/exp(100)))
mean(rexp(100, 1/exp(-100)))
mean(rlnorm(100, -100, 1))
Inference
dexp
pexp
rexp(10, c(1:10) )
rexp(10, 1/c(1:10) )
set.seed(1)
rexp(10, 1/c(1:10) )
set.seed(1)
rexp(1, 1)
rexp(1, 2)
rexp(1, 3)
set.seed(1)
rexp(1, 1)
rexp(1, 1/2)
mean(rexp(100, exp(-10)))
mean(rlnorm(100, -10, 1))
mean(rexp(100, 1/exp(-10)))
mean(rlnorm(100, -10, 1))
mean(rexp(100, 1/exp(-10)))
plot(Montgomery_infer2$eta[,1], type = 'l')
plot(Montgomery_infer2$eta[,2], type = 'l')
plot(Montgomery_infer2$eta[,3], type = 'l')
plot(Montgomery_infer2$eta[,4], type = 'l')
plot(Montgomery_infer2$eta[,5], type = 'l')
plot(Montgomery_infer2$eta[,6], type = 'l')
plot(Montgomery_infer2$eta[,7], type = 'l')
plot(Montgomery_infer2$eta[,8], type = 'l')
colMeans(Montgomery_infer2$eta)
colMeans(Montgomery_infer$eta)
dexp(10, 1/10)
dexp(10, 1)
dexp(10, 11)
dexp(10, 1/11)
rexp(1, 1/exp(-2))
rexp(1, 1/exp(-1))
rexp(1, 1/exp(-2))
rexp(1, 1/exp(-1))
rexp(10, 1/exp(-2))
rexp(10, 1/exp(-1))
hi = 10
-1/10
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
#
D = 100#
A = 5#
P = 4#
#Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
X[,,,1] = 1#
#Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
Q = 3#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
  Y[,a,2] = a#
  if (a != 1) {#
    Y[,a,3] = 0#
  }#
}#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = c(-3, rep(0, P-1)), var = diag(P))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 3, b = 1)#
Nsamp = 10^5#
outer = 50#
inner = c(5, 5, 5)#
burn = 0#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
  if (n %% 100 == 0) print(n)#
  beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
  eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
  sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
  initial = Generate(D, A, beta, eta, sigma2, X, Y, support)#
  infer = Inference(initial$data, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, #
                    initial = initial, proposal.var = c(0.01, 0.1, 0.01, 0.5), lasttime = 0)#
  initial2 = Generate(D, A, infer$beta[outer,], infer$eta[outer,], infer$sigma2[outer,], X, Y, support)                  #
  result[n, ] = c(mean(vapply(initial$data, function(x) sum(x$r_d), c(1))),#
 				 mean(vapply(2:D, function(d) initial$data[[d]]$t_d-initial$data[[d-1]]$t_d, c(1))),#
                  initial$beta, initial$eta, initial$sigma2, #
                 mean(vapply(initial2$data, function(x) sum(x$r_d), c(1))),#
                  mean(vapply(2:D, function(d) initial2$data[[d]]$t_d-initial2$data[[d-1]]$t_d, c(1))),#
                  initial2$beta, initial2$eta, initial2$sigma2)			 #
}#
par(mfrow=c(2,5))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
D = 100#
A = 5#
P = 4#
#Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
X[,,,1] = 1#
#Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
Q = 3#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
  Y[,a,2] = a#
  if (a != 1) {#
    Y[,a,3] = 0#
  }#
}#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = c(-3, rep(0, P-1)), var = diag(P))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 3, b = 1)#
Nsamp = 10^5#
outer = 10#
inner = c(5, 5, 5)#
burn = 0#
#Schein test#
result = matrix(NA, Nsamp, 2*(3+P+Q))#
for (n in 1:Nsamp) {#
  if (n %% 100 == 0) print(n)#
  beta = rmvnorm_arma(1, prior.beta$mean, prior.beta$var)#
  eta = rmvnorm_arma(1, prior.eta$mean, prior.eta$var)#
  sigma2 = rinvgamma(1, prior.sigma2$a, prior.sigma2$b)#
  initial = Generate(D, A, beta, eta, sigma2, X, Y, support)#
  infer = Inference(initial$data, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, #
                    initial = initial, proposal.var = c(0.01, 0.1, 0.01, 0.5), lasttime = 0)#
  initial2 = Generate(D, A, infer$beta[outer,], infer$eta[outer,], infer$sigma2[outer,], X, Y, support)                  #
  result[n, ] = c(mean(vapply(initial$data, function(x) sum(x$r_d), c(1))),#
 				 mean(vapply(2:D, function(d) initial$data[[d]]$t_d-initial$data[[d-1]]$t_d, c(1))),#
                  initial$beta, initial$eta, initial$sigma2, #
                 mean(vapply(initial2$data, function(x) sum(x$r_d), c(1))),#
                  mean(vapply(2:D, function(d) initial2$data[[d]]$t_d-initial2$data[[d-1]]$t_d, c(1))),#
                  initial2$beta, initial2$eta, initial2$sigma2)			 #
}#
par(mfrow=c(2,5))#
GiR_PP_Plots(result[,c(1:(3+P+Q))], result[,c((4+P+Q):(2*(3+P+Q)))])
load('~/Desktop/result.RData')
Forward_stats = result[,c(1:(3+P+Q))]#
Backward_stats = result[,c((4+P+Q):(2*(3+P+Q)))]#
colnames(Forward_stats) = c("Mean Recipient Size", "Mean Time-increments", sapply(1:P, function(p){paste0("b",p," Estimates")}), sapply(1:Q, function(q){paste0(expression(eta),q," Estimates")}), "Variance Estimate")#
plot = list()#
library(ggplot2)#
 nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
  	data = data.frame(qx1 = qx1, qx2 = qx2)#
	plot[[i]] =qplot(data = data, x = qx1, y = qx2, colour = I("blue"), size = I(0.5)) + labs(x = "Forward", y = "Backward")+geom_abline(intercept = 0, col = 'red') + theme(text = element_text(size = rel(3)), plot.title= element_text(size=rel(3)))#
	#+labs(title = expression(nms[i]))#
}	#
library(gridExtra)#
library(latex2exp)#
grid.arrange(arrangeGrob(plot[[1]]+labs(title = "Mean Recipient Size"),#
	plot[[2]]+labs(title = "Mean Time-increments"),plot[[3]]+labs(title = expression(b*" Estimates for p=1")),plot[[4]]+labs(title = expression(b*" Estimates for p=2")),plot[[5]]+labs(title = expression(b*" Estimates for p=3")),#
plot[[6]]+labs(title = expression(b*" Estimates for p=4")),plot[[7]]+labs(title = expression(eta*" Estimates for q=1")),plot[[8]]+labs(title = expression(eta*" Estimates for q=2")),plot[[9]]+labs(title = expression(eta*" Estimates for q=3")),plot[[10]]+labs(title = expression(sigma^2*" Estimates")), nrow=4),        heights=c(10, 1))
D = 100#
A = 5#
P = 4#
#Q = 3#
X = array(rnorm(D*A*A*P), dim = c(D,A,A,P))#
X[,,,1] = 1#
#Y = array(rnorm(D*A*Q), dim = c(D,A,Q))#
Q = 3#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
  Y[,a,2] = a#
  if (a != 1) {#
    Y[,a,3] = 0#
  }#
}#
support = gibbs.measure.support(A-1)#
prior.beta = list(mean = c(-3, rep(0, P-1)), var = diag(P))#
prior.eta = list(mean = rep(0, Q), var = diag(Q))#
prior.sigma2 = list(a = 3, b = 1)
Forward_stats = result[,c(1:(3+P+Q))]#
Backward_stats = result[,c((4+P+Q):(2*(3+P+Q)))]#
colnames(Forward_stats) = c("Mean Recipient Size", "Mean Time-increments", sapply(1:P, function(p){paste0("b",p," Estimates")}), sapply(1:Q, function(q){paste0(expression(eta),q," Estimates")}), "Variance Estimate")#
plot = list()#
library(ggplot2)#
 nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
  	data = data.frame(qx1 = qx1, qx2 = qx2)#
	plot[[i]] =qplot(data = data, x = qx1, y = qx2, colour = I("blue"), size = I(0.5)) + labs(x = "Forward", y = "Backward")+geom_abline(intercept = 0, col = 'red') + theme(text = element_text(size = rel(3)), plot.title= element_text(size=rel(3)))#
	#+labs(title = expression(nms[i]))#
}	#
library(gridExtra)#
library(latex2exp)#
grid.arrange(arrangeGrob(plot[[1]]+labs(title = "Mean Recipient Size"),#
	plot[[2]]+labs(title = "Mean Time-increments"),plot[[3]]+labs(title = expression(b*" Estimates for p=1")),plot[[4]]+labs(title = expression(b*" Estimates for p=2")),plot[[5]]+labs(title = expression(b*" Estimates for p=3")),#
plot[[6]]+labs(title = expression(b*" Estimates for p=4")),plot[[7]]+labs(title = expression(eta*" Estimates for q=1")),plot[[8]]+labs(title = expression(eta*" Estimates for q=2")),plot[[9]]+labs(title = expression(eta*" Estimates for q=3")),plot[[10]]+labs(title = expression(sigma^2*" Estimates")), nrow=4),        heights=c(10, 1))
nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
  	data = data.frame(qx1 = qx1, qx2 = qx2)#
	plot[[i]] =qplot(data = data, x = qx1, y = qx2, colour = I("blue"), size = I(0.5)) + labs(x = "Forward", y = "Backward")+geom_abline(intercept = 0, col = 'red') + theme(text = element_text(size = rel(3)), plot.title= element_text(size=rel(4)))#
	#+labs(title = expression(nms[i]))#
}	#
library(gridExtra)#
library(latex2exp)#
grid.arrange(arrangeGrob(plot[[1]]+labs(title = "Mean Recipient Size"),#
	plot[[2]]+labs(title = "Mean Time-increments"),plot[[3]]+labs(title = expression(b*" Estimates for p=1")),plot[[4]]+labs(title = expression(b*" Estimates for p=2")),plot[[5]]+labs(title = expression(b*" Estimates for p=3")),#
plot[[6]]+labs(title = expression(b*" Estimates for p=4")),plot[[7]]+labs(title = expression(eta*" Estimates for q=1")),plot[[8]]+labs(title = expression(eta*" Estimates for q=2")),plot[[9]]+labs(title = expression(eta*" Estimates for q=3")),plot[[10]]+labs(title = expression(sigma^2*" Estimates")), nrow=3),        heights=c(10, 1))
grid.arrange(arrangeGrob(plot[[1]]+labs(title = "Mean Recipient Size"),#
	plot[[2]]+labs(title = "Mean Time-increments"),plot[[3]]+labs(title = expression(b*" Estimates for p=1")),plot[[4]]+labs(title = expression(b*" Estimates for p=2")),plot[[5]]+labs(title = expression(b*" Estimates for p=3")),#
plot[[6]]+labs(title = expression(b*" Estimates for p=4")),plot[[7]]+labs(title = expression(eta*" Estimates for q=1")),plot[[8]]+labs(title = expression(eta*" Estimates for q=2")),plot[[9]]+labs(title = expression(eta*" Estimates for q=3")),plot[[10]]+labs(title = expression(sigma^2*" Estimates")), nrow=2),        heights=c(10, 1))
grid.arrange(arrangeGrob(plot[[1]]+labs(title = "Mean Recipient Size"),#
	plot[[2]]+labs(title = "Mean Time-increments"),plot[[3]]+labs(title = expression(b*" Estimates for p=1")),plot[[4]]+labs(title = expression(b*" Estimates for p=2")),plot[[5]]+labs(title = expression(b*" Estimates for p=3")),#
plot[[6]]+labs(title = expression(b*" Estimates for p=4")),plot[[7]]+labs(title = expression(eta*" Estimates for q=1")),plot[[8]]+labs(title = expression(eta*" Estimates for q=2")),plot[[9]]+labs(title = expression(eta*" Estimates for q=3")),plot[[10]]+labs(title = expression(sigma^2*" Estimates")), nrow=2))
#source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
#
library(MulticastNetwork)#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 14#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)) {#
		  if (r != a) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		  }#
		    X[d, a, , 12] = 1* (Montgomery$manager_gender[a]=="Female")#
			  X[d, a, r, 13] =1* (Montgomery$manager_gender[r]=="Female")#
			  X[d, a, r, 14] =1* (Montgomery$manager_gender[a]==Montgomery$manager_gender[r])#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] <sum(X[d,a,,4]),sum(X[d,a,,4])/outdegree[a] , 1)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
set.seed(1)#
missing = list()#
#missingness of senders#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)    #
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
#missingness of receivers#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)    #
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
#missingness of timestamps#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
for (d in 1:dim(Y)[1]) {#
	if (missing[[1]][d,1] == 1) {#
		edge[[d]]$a_d = NA#
	}#
	if (sum(missing[[2]][d,]) > 0) {#
		edge[[d]]$r_d[which(missing[[2]][d,]==1)] = NA#
	}#
	if (missing[[3]][d,1] == 1) {#
		edge[[d]]$t_d = NA#
	}#
}#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
#
#will generate 500 predictions (iterate two steps: imputation -> inference)#
Montgomery_PPE = PPE(edge, X, Y, 550, c(5,5,1), 50, prior.beta, prior.eta, prior.sigma2, #
                     initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, #
                     lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.15, timedist = "lognormal")
load('~/Desktop/Montgomery_infer.RData')
set.seed(1)#
missing = list()#
#missingness of senders#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)    #
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
#missingness of receivers#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)    #
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
#missingness of timestamps#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
for (d in 1:dim(Y)[1]) {#
	if (missing[[1]][d,1] == 1) {#
		edge[[d]]$a_d = NA#
	}#
	if (sum(missing[[2]][d,]) > 0) {#
		edge[[d]]$r_d[which(missing[[2]][d,]==1)] = NA#
	}#
	if (missing[[3]][d,1] == 1) {#
		edge[[d]]$t_d = NA#
	}#
}#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
#
#will generate 500 predictions (iterate two steps: imputation -> inference)#
Montgomery_PPE = PPE(edge, X, Y, 550, c(5,5,1), 50, prior.beta, prior.eta, prior.sigma2, #
                     initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, #
                     lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.15, timedist = "lognormal")
dim(X)
load('~/Desktop/Montgomery_infer.RData')
set.seed(1)#
missing = list()#
#missingness of senders#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)    #
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
#missingness of receivers#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)    #
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
#missingness of timestamps#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
for (d in 1:dim(Y)[1]) {#
	if (missing[[1]][d,1] == 1) {#
		edge[[d]]$a_d = NA#
	}#
	if (sum(missing[[2]][d,]) > 0) {#
		edge[[d]]$r_d[which(missing[[2]][d,]==1)] = NA#
	}#
	if (missing[[3]][d,1] == 1) {#
		edge[[d]]$t_d = NA#
	}#
}#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)
intiail$beta
initial$beta
#will generate 500 predictions (iterate two steps: imputation -> inference)#
Montgomery_PPE = PPE(edge, X, Y, 550, c(5,5,1), 50, prior.beta, prior.eta, prior.sigma2, #
                     initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, #
                     lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.15, timedist = "lognormal")
save(Montgomery_PPE, file = "/Users/bomin8319/Desktop/Montgomery_PPE.RData")
load('~/Desktop/MulticastNetwork/Emails/Montgomery_PPE2.RData')
library(gridExtra)#
library(latex2exp)#
p = list()#
##################
truesender = sapply(Montgomery_PPE$sendermissing, function(d) edge[[d]]$a_d)#
predprob = Montgomery_PPE$senderprob/rowSums(Montgomery_PPE$senderprob)#
predprob2 = Montgomery_PPE2$senderprob/rowSums(Montgomery_PPE2$senderprob)#
#
sender = data.frame(probtrue = sapply(1:62, function(d) predprob[d,truesender[d]]), dist = rep("lognormal", 62))#
sender = rbind(sender, data.frame(probtrue = sapply(1:62, function(d) predprob2[d,truesender[d]]), dist = rep("exponential", 62)))#
library(ggplot2)#
library(reshape)#
sender = melt(sender)#
colnames(sender)[3] = "correct"#
p[[1]]=ggplot(data = sender, aes(x = dist, y = correct, fill = dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)#
boxplot(sapply(1:62, function(d) predprob[d,truesender[d]]), sapply(1:62, function(d) predprob2[d,truesender[d]]))
load("/Users/bomin8319/Box/gainlab_example/Bomin/Montgomery.RData")#
edge = Montgomery$edge#
X = Montgomery$X#
Y = Montgomery$Y#
P = dim(X)[4]#
Q = dim(Y)[3]#
A = dim(Y)[2]
truesender = sapply(Montgomery_PPE$sendermissing, function(d) edge[[d]]$a_d)#
predprob = Montgomery_PPE$senderprob/rowSums(Montgomery_PPE$senderprob)#
predprob2 = Montgomery_PPE2$senderprob/rowSums(Montgomery_PPE2$senderprob)#
#
sender = data.frame(probtrue = sapply(1:62, function(d) predprob[d,truesender[d]]), dist = rep("lognormal", 62))#
sender = rbind(sender, data.frame(probtrue = sapply(1:62, function(d) predprob2[d,truesender[d]]), dist = rep("exponential", 62)))#
library(ggplot2)#
library(reshape)#
sender = melt(sender)#
colnames(sender)[3] = "correct"#
p[[1]]=ggplot(data = sender, aes(x = dist, y = correct, fill = dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)#
boxplot(sapply(1:62, function(d) predprob[d,truesender[d]]), sapply(1:62, function(d) predprob2[d,truesender[d]]))
p[[1]]
truesender = sapply(Montgomery_PPE$sendermissing, function(d) edge[[d]]$a_d)#
predprob = Montgomery_PPE$senderprob/rowSums(Montgomery_PPE$senderprob)#
predprob2 = Montgomery_PPE2$senderprob/rowSums(Montgomery_PPE2$senderprob)#
#
sender = data.frame(probtrue = sapply(1:62, function(d) predprob[d,truesender[d]]), Dist = rep("log-normal", 62))#
sender = rbind(sender, data.frame(probtrue = sapply(1:62, function(d) predprob2[d,truesender[d]]), Dist = rep("exponential", 62)))#
library(ggplot2)#
library(reshape)#
sender = melt(sender)#
colnames(sender)[3] = "correct"
head(sender)
ggplot(data = sender, aes(x = Dist, y = correct, fill = dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)
ggplot(data = sender, aes(x = Dist, y = correct, fill = dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)
truesender = sapply(Montgomery_PPE$sendermissing, function(d) edge[[d]]$a_d)#
predprob = Montgomery_PPE$senderprob/rowSums(Montgomery_PPE$senderprob)#
predprob2 = Montgomery_PPE2$senderprob/rowSums(Montgomery_PPE2$senderprob)#
#
sender = data.frame(probtrue = sapply(1:62, function(d) predprob[d,truesender[d]]), Dist = rep("log-normal", 62))#
sender = rbind(sender, data.frame(probtrue = sapply(1:62, function(d) predprob2[d,truesender[d]]), Dist = rep("exponential", 62)))#
library(ggplot2)#
library(reshape)#
sender = melt(sender)#
colnames(sender)[3] = "correct"#
p[[1]]=ggplot(data = sender, aes(x = Dist, y = correct, fill = dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)
p[[1]]
edge = Montgomery$edge#
X = Montgomery$X#
Y = Montgomery$Y#
P = dim(X)[4]#
Q = dim(Y)[3]#
A = dim(Y)[2]
truesender = sapply(Montgomery_PPE$sendermissing, function(d) edge[[d]]$a_d)#
predprob = Montgomery_PPE$senderprob/rowSums(Montgomery_PPE$senderprob)#
predprob2 = Montgomery_PPE2$senderprob/rowSums(Montgomery_PPE2$senderprob)#
#
sender = data.frame(probtrue = sapply(1:62, function(d) predprob[d,truesender[d]]), Dist = rep("log-normal", 62))#
sender = rbind(sender, data.frame(probtrue = sapply(1:62, function(d) predprob2[d,truesender[d]]), Dist = rep("exponential", 62)))#
library(ggplot2)#
library(reshape)#
sender = melt(sender)#
colnames(sender)[3] = "correct"
ggplot(data = sender, aes(x = Dist, y = correct, fill = dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)
ggplot(data = sender, aes(x = Dist, y = correct, fill = Dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)
ggplot(data = sender, aes(x = Dist, y = correct, fill = Dist))+geom_boxplot()+ylab("Correct sender posterior probability")+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
ggplot(data = sender, aes(x = Dist, y = correct, fill = Dist))+geom_boxplot()+ylab(expression(pi))+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
ggplot(data = sender, aes(x = Dist, y = correct, fill = Dist))+geom_boxplot()+ylab(expression(pi))+geom_hline(yintercept=1/18, col = 'blue', lty=2, lwd=1)+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
library(MLmetrics)#
#
truereceiver = unlist(sapply(Montgomery_PPE$receivermissing, function(d) edge[[d]]$r_d[which(missing[[2]][d,]==1)]))#
predreceiver = Montgomery_PPE$receiverpredict#
predreceiver2 = Montgomery_PPE2$receiverpredict#
#
probtrue = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver[,d], 1))#
probtrue2 = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver2[,d], 1))#
#
receiver = data.frame(F1score = probtrue, dist = rep("lognormal", 500))#
receiver = rbind(receiver, data.frame(F1score = probtrue2, dist = rep("exponential", 500)))#
receiver = melt(receiver)#
colnames(receiver)[3] = "F1score"#
p[[2]]=ggplot(data = receiver, aes(x = dist, y = F1score, fill = dist))+geom_boxplot()+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
p[[2]]
truereceiver = unlist(sapply(Montgomery_PPE$receivermissing, function(d) edge[[d]]$r_d[which(missing[[2]][d,]==1)]))#
predreceiver = Montgomery_PPE$receiverpredict#
predreceiver2 = Montgomery_PPE2$receiverpredict#
#
probtrue = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver[,d], 1))#
probtrue2 = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver2[,d], 1))#
#
receiver = data.frame(F1 = probtrue, dist = rep("lognormal", 500))#
receiver = rbind(receiver, data.frame(F1 = probtrue2, dist = rep("exponential", 500)))#
receiver = melt(receiver)#
colnames(receiver)[3] = "F1"#
p[[2]]=ggplot(data = receiver, aes(x = dist, y = F1, fill = dist))+geom_boxplot()+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
p[[2]]
p[[2]]
truetime = sapply(Montgomery_PPE$timemissing, function(d) edge[[d]]$t_d-edge[[d-1]]$t_d)/3600#
predtime = Montgomery_PPE$timepredict#
predtime2 = Montgomery_PPE2$timepredict#
#
time = data.frame(MdAPE = sapply(1:62, function(d) median(abs((predtime[d,]-truetime[d])/truetime[d]))), dist = rep("lognormal", 62))#
time = rbind(time, data.frame(MdAPE = sapply(1:62, function(d) median(abs((predtime2[d,]-truetime[d])/truetime[d]))), dist = rep("exponential", 62)))#
time$MdAPE = log(time$MdAPE)#
time = melt(time)#
stats = boxplot.stats(time$value)$stats#
#
colnames(time)[3] = "MdAPE"#
p[[3]]=ggplot(data = time, aes(x = dist, y = MdAPE, fill = dist))+geom_boxplot()+theme(legend.position = "bottom")+ylab("log(MdAPE)")#
ggplot(data = time, aes(x = MdAPE, fill = dist))+geom_histogram(position = "dodge")+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
time = data.frame(MdAE = sapply(1:62, function(d) mean(abs((predtime[d,]-truetime[d])/truetime[d]))), dist = rep("lognormal", 62))#
time = rbind(time, data.frame(MdAE = sapply(1:62, function(d) mean(abs((predtime2[d,]-truetime[d])/truetime[d]))), dist = rep("exponential", 62)))#
time$MdAE = log(time$MdAE)#
#
time = melt(time)#
colnames(time)[3] = "MdAE"#
ggplot(data = time, aes(x = dist, y = MdAE, fill = dist))+geom_boxplot()+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
truereceiver = unlist(sapply(Montgomery_PPE$receivermissing, function(d) edge[[d]]$r_d[which(missing[[2]][d,]==1)]))#
predreceiver = Montgomery_PPE$receiverpredict#
predreceiver2 = Montgomery_PPE2$receiverpredict#
#
probtrue = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver[,d], 1))#
probtrue2 = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver2[,d], 1))#
#
receiver = data.frame(F1 = probtrue, dist = rep("log-normal", 500))#
receiver = rbind(receiver, data.frame(F1 = probtrue2, dist = rep("exponential", 500)))#
receiver = melt(receiver)#
colnames(receiver)[3] = "F1"#
p[[2]]=ggplot(data = receiver, aes(x = dist, y = F1, fill = dist))+geom_boxplot()+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
p[[2]]
truereceiver = unlist(sapply(Montgomery_PPE$receivermissing, function(d) edge[[d]]$r_d[which(missing[[2]][d,]==1)]))#
predreceiver = Montgomery_PPE$receiverpredict#
predreceiver2 = Montgomery_PPE2$receiverpredict#
#
probtrue = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver[,d], 1))#
probtrue2 = sapply(1:500, function(d) F1_Score(truereceiver, predreceiver2[,d], 1))#
#
receiver = data.frame(F1 = probtrue, Dist = rep("log-normal", 500))#
receiver = rbind(receiver, data.frame(F1 = probtrue2, Dist = rep("exponential", 500)))#
receiver = melt(receiver)#
colnames(receiver)[3] = "F1"#
p[[2]]=ggplot(data = receiver, aes(x = Dist, y = F1, fill = Dist))+geom_boxplot()+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
p[[2]]
time = data.frame(MdAE = sapply(1:62, function(d) mean(abs((predtime[d,]-truetime[d])/truetime[d]))), Dist = rep("log-normal", 62))#
time = rbind(time, data.frame(MdAE = sapply(1:62, function(d) mean(abs((predtime2[d,]-truetime[d])/truetime[d]))), Dist = rep("exponential", 62)))#
time$MdAE = log(time$MdAE)#
#
time = melt(time)#
colnames(time)[3] = "MdAE"#
ggplot(data = time, aes(x = Dist, y = MdAE, fill = Dist))+geom_boxplot()+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
time = data.frame(MdAE = sapply(1:62, function(d) mean(abs((predtime[d,]-truetime[d])/truetime[d]))), Dist = rep("log-normal", 62))#
time = rbind(time, data.frame(MdAE = sapply(1:62, function(d) mean(abs((predtime2[d,]-truetime[d])/truetime[d]))), Dist = rep("exponential", 62)))
time = melt(time)#
colnames(time)[3] = "MdAE"#
ggplot(data = time, aes(x = Dist, y = MdAE, fill = Dist))+geom_boxplot()+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
names(Montgomery_PPE)
head(Montgomery_PPE$timepredict)
head(Montgomery_PPE2$timepredict)
truetime = sapply(Montgomery_PPE$timemissing, function(d) edge[[d]]$t_d-edge[[d-1]]$t_d)/3600#
predtime = Montgomery_PPE$timepredict#
predtime2 = Montgomery_PPE2$timepredict#
#
time = data.frame(MdAPE = sapply(1:62, function(d) median(abs((predtime[d,]-truetime[d])/truetime[d]))), dist = rep("lognormal", 62))#
time = rbind(time, data.frame(MdAPE = sapply(1:62, function(d) median(abs((predtime2[d,]-truetime[d])/truetime[d]))), dist = rep("exponential", 62)))#
time$MdAPE = log(time$MdAPE)#
time = melt(time)#
stats = boxplot.stats(time$value)$stats#
#
colnames(time)[3] = "MdAPE"#
p[[3]]=ggplot(data = time, aes(x = dist, y = MdAPE, fill = dist))+geom_boxplot()+theme(legend.position = "bottom")+ylab("log(MdAPE)")#
ggplot(data = time, aes(x = MdAPE, fill = dist))+geom_histogram(position = "dodge")+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
##################################################
truetime = sapply(Montgomery_PPE$timemissing, function(d) edge[[d]]$t_d-edge[[d-1]]$t_d)/3600#
predtime = Montgomery_PPE$timepredict#
predtime2 = Montgomery_PPE2$timepredict#
#
time = data.frame(MdAPE = sapply(1:62, function(d) median(abs((predtime[d,]-truetime[d])/truetime[d]))), Dist = rep("log-normal", 62))#
time = rbind(time, data.frame(MdAPE = sapply(1:62, function(d) median(abs((predtime2[d,]-truetime[d])/truetime[d]))), Dist = rep("exponential", 62)))#
time$MdAPE = log(time$MdAPE)#
time = melt(time)#
stats = boxplot.stats(time$value)$stats#
#
colnames(time)[3] = "MdAPE"#
p[[3]]=ggplot(data = time, aes(x = Dist, y = MdAPE, fill = Dist))+geom_boxplot()+theme(legend.position = "bottom")+ylab("log(MdAPE)")
p[[3]]
p[[3]]=ggplot(data = time, aes(x = Dist, y = MdAPE, fill = Dist))+geom_boxplot()+theme(legend.position = "bottom")+ylab("log(MdAPE)")+theme(plot.title = element_blank(),text = element_text(size = rel(5.5)),legend.position="none")
p[[3]]
