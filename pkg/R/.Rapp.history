0.1*dim(Y)[1]
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing
sum(missing[[1]]==1 & missing[[3]]==1)
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)
missing[[2]]
0.1*(dim(Y)[1]*A)
missing[[2]][sample(1:(dim(Y)[1]*A), 0.1*(dim(Y)[1]*A), replace = FALSE)] = 1
missing[[2]]
rowSums(missing[[2]])
sum(missing[[2]])
0.1*(dim(Y)[1]*A)
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)#
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
missing[[2]]
which(rowSums(missing[[2]])>0)
edge[[1]]
edge[[1]][[2]]
edge[[1]][[2]][which(missing[[2]][d,]==1)]
d
d = 1
edge[[1]][[2]][which(missing[[2]][d,]==1)]
d
d = 2
edge[[1]][[2]][which(missing[[2]][d,]==1)]
u[[d]][sender[d], which(missing[[2]][d,]==1)]
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")
names(Montgomery_infer)
Montgomery_infer$u[[1]]
length(Montgomery_infer$u)
Montgomery_infer$u[[d]][sender[d], which(missing[[2]][d,]==1)]
Montgomery_infer$u[[d]][1, which(missing[[2]][d,]==1)]
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")
PPE
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
dlnorm(mu[d,], sigma_tau, timeinc[d])
dlnorm
dlnorm(10, rnorm(5), 1)
mean = c(1,2,3,4,5)
dlnorm(10, mean, 1)
dlnorm(10, 1, 1)
dlnorm(10, 2, 1)
sourceCpp('/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast_rcpp.cpp')
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        senders[d] = rmultinom(1, 1, probi)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, sender[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][sender[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
warnings()
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        browser()#
        senders[d] = rmultinom(1, 1, probi)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, sender[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][sender[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
probi
rmultinom(1, 1, probi)
which(rmultinom(1, 1, probi)==1)
Q
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        senders[d] = which(rmultinom(1, 1, probi)==1)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, sender[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][sender[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
# missing is a list object#
PPE = function(data, missing, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initial = initial,#
		proposal.var, timeunit = 3600, lasttime) {#
	D = dim(X)[1]#
	A = dim(X)[2]#
	P = dim(X)[4]#
	Q = dim(Y)[3]#
	if (length(initial) > 0) {#
		u = initial$u#
		beta = initial$beta#
		eta = initial$eta#
		sigma2 = initial$sigma2#
	} else {#
		u = lapply(1:D, function(d) matrix(0, A, A))#
		beta = matrix(prior.beta$mean, nrow = 1)#
		eta = matrix(prior.eta$mean, nrow = 1)#
		sigma2 = prior.sigma2$b / (prior.sigma2$a-1)#
	}#
	mu = mu_cpp(Y, eta)#
	#output matrix#
	betamat = matrix(beta, nrow = outer-burn, ncol = P)#
	etamat = matrix(eta, nrow = outer-burn, ncol = Q)#
	sigma2mat = matrix(sigma2, nrow = outer-burn, ncol = 1)#
	loglike = matrix(NA, nrow = outer-burn, ncol = 1)#
	senders = vapply(data, function(d) { d[[1]] }, c(1))#
	timestamps = vapply(data, function(d) { d[[3]] }, c(1))#
	timeinc = c(timestamps[1]-lasttime, timestamps[-1]-timestamps[-length(timestamps)]) / timeunit#
	timeinc[timeinc == 0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
	senderpredict = matrix(NA, nrow = sum(missing[[1]]), ncol = outer)#
    receiverpredict = matrix(NA, nrow = sum(missing[[2]]), ncol = outer)#
    timepredict = matrix(NA, nrow = sum(missing[[3]]), ncol = outer)#
    sendermissing = which(missing[[1]]==1)#
    receivermissing = which(rowSums(missing[[2]]) > 0)#
    timemissing = which(missing[[3]]==1)#
	for (o in 1:outer) {#
	#imputation#
    iter1 = 1#
    iter2 = 1#
    iter3 = 1#
    for (d in sendermissing) {#
        probi = Timepartindiv(mu[d,], sqrt(sigma2), timeinc[d])#
        senders[d] = which(rmultinom(1, 1, probi)==1)#
        senderpredict[iter1, o] = senders[d]#
        iter1 = iter1+1#
    }#
    for (d in timemissing) {#
        timeinc[d] = rlnorm(1, mu[d, senders[d]], sqrt(sigma2))#
        timepredict[iter2, o] = timeinc[d]#
        iter2 = iter2+1#
    }    #
    timeinc[timeinc==0] = runif(sum(timeinc==0), 0, min(timeinc[timeinc!=0]))#
#
    for (d in receivermissing) {#
    	data[[d]][[2]][which(missing[[2]][d,]==1)] = u[[d]][senders[d], which(missing[[2]][d,]==1)]#
        receiverpredict[iter3, o] = data[[d]][[2]][which(missing[[2]][d,]==1)]#
		iter3 = iter3+1#
    }  #
#
	#run inference#
		if (o %% 100 == 0) print(o)#
		lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta))#
		u = u_cpp(lambda, u)#
		for (d in 1:D) {#
		  u[[d]][senders[d],] = data[[d]][[2]]#
		}#
		prior.old1 = dmvnorm_arma(beta, prior.beta$mean, prior.beta$var)#
    	post.old1 = Edgepartsum(lambda, u)#
    	for (i1 in 1:inner[1]) {#
			beta.new = rmvnorm_arma(1, beta, proposal.var[1]*diag(P))#
     		prior.new1 = dmvnorm_arma(beta.new, prior.beta$mean, prior.beta$var)#
			lambda = lapply(1:D, function(d) lambda_cpp(X[d,,,], beta.new))#
			post.new1 = Edgepartsum(lambda, u)#
      		loglike.diff = prior.new1+post.new1-prior.old1-post.old1#
			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			beta = beta.new#
        			prior.old1 = prior.new1#
        			post.old1 = post.new1#
	      	}#
		}#
		prior.old2 = dmvnorm_arma(eta, prior.eta$mean, prior.eta$var) #
    	mu = mu_cpp(Y, eta)#
   		post.old2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
		for (i2 in 1:inner[2]) {#
			eta.new = rmvnorm_arma(1, eta, proposal.var[2]*diag(Q))#
      		prior.new2 = dmvnorm_arma(eta.new, prior.eta$mean, prior.eta$var) 	#
      		mu = mu_cpp(Y, eta.new)#
    		post.new2 = Timepartsum(mu, sqrt(sigma2), senders, timeinc)#
    		loglike.diff = prior.new2+post.new2-prior.old2-post.old2#
      		if (log(runif(1, 0, 1)) < loglike.diff) {#
        			eta = eta.new#
        			prior.old2 = prior.new2#
        			post.old2 = post.new2#
	      	}#
		}#
		prior.old3 = dinvgamma(sigma2, prior.sigma2$a, prior.sigma2$b) #
    	post.old3 = post.old2#
   	 	mu = mu_cpp(Y, eta)#
#
		for (i3 in 1:inner[3]) {#
			sigma2.new = exp(rnorm(1, log(sigma2), proposal.var[3]))#
     	 	prior.new3 = dinvgamma(sigma2.new, prior.sigma2$a, prior.sigma2$b)#
    		post.new3 = Timepartsum(mu, sqrt(sigma2.new), senders, timeinc)#
    		loglike.diff = prior.new3+post.new3-prior.old3-post.old3#
    			if (log(runif(1, 0, 1)) < loglike.diff) {#
        			sigma2 = sigma2.new#
        			prior.old3 = prior.new3#
        			post.old3 = post.new3#
	      	}#
		}#
		if (o > burn) {#
			betamat[o-burn, ] = beta#
			etamat[o-burn, ] = eta#
			sigma2mat[o-burn, ] = sigma2	#
			loglike[o-burn, ] = post.old1 + post.old3#
		}		#
	}#
	return(list(senderpredict = senderpredict, receiverpredict = receiverpredict, timepredict = timepredict))#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/code/Montgomery_infer.RData")#
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
Montgomery_PPE = list()#
for (n in 1:100) {#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 100, c(5,1,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime)#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
exp(-0.4)
exp(-3.5)
recipients = tabulate(rowSums(email[trim,3:20]), A-1)
recipients
recipients = table(rowSums(email[trim,3:20]))
recipients
Montgomery_infer$department
names(Montgomery)
Montgomery$manager_department
hello = rowSums(email[trim,3:20])
which(hello >=10)
senders[which(hello >=10)]
senders = email[,2]
senders
senders[which(hello >=10)]
table(senders)
senders[which(hello >=8)]
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
A = length(Montgomery$manager_gender)#
#
#observed statistics#
timeunit = 3600#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
#
outdegree = tabulate(email[trim,2], A)#
indegree = colSums(email[trim,3:20])#
recipients = tabulate(rowSums(email[trim,3:20]), A-1)#
timeinc = diff(sort(email$timepoints)[43:max(trim)])/3600
indegreedist = matrix(NA, 500, A)#
outdegreedist = matrix(NA,  500, A)#
recipientsdist = matrix(NA,  500, A-1)#
timedist = matrix(NA, 500, 621)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code")#
for (n in 1:500) {#
	filename = paste0("Montgomery_PPCnew", n,".RData")#
	load(filename)#
	outdegreedist[n, ] = tabulate(vapply(1:621, function(x) Montgomery_PPC[[x]]$a_d, c(1)), A)#
	indegreedist[n, ] = rowSums(sapply(1:621, function(x) Montgomery_PPC[[x]]$r_d))#
	recipientsdist[n, ] = tabulate(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$r_d), c(1)), A-1)#
	timedist[n, ] = c(email$timepoints[42], diff(vapply(1:621, function(x) sum(Montgomery_PPC[[x]]$t_d), c(1)))) / timeunit#
}
par(mfrow = c(3,1))#
#
# indegreesum = table(floor(indegreedist/10))#
# boxplot(floor(indegreedist/10))#
#
boxplot(outdegreedist, ylim = c(0, 175), main = "outdegree")#
lines(outdegree, col = 2)#
#
boxplot(indegreedist,ylim = c(0, 275),  main = "indegree")#
lines(indegree, col = 2)#
#
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")#
lines(recipients, col = 2)
par(mfrow = c(1,1))
boxplot(outdegreedist, ylim = c(0, 175), main = "outdegree")#
lines(outdegree, col = 2)
boxplot(indegreedist,ylim = c(0, 275),  main = "indegree")#
lines(indegree, col = 2)
boxplot(outdegreedist, ylim = c(0, 175), main = "outdegree")#
lines(outdegree, col = 2)
boxplot(indegreedist,ylim = c(0, 275),  main = "indegree")#
lines(indegree, col = 2)
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")#
lines(recipients, col = 2)
hi = quantile(c(timedist[,-1]), c(.025, .975 ))#
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc, xlab = "post", ylab = "obs", main = "timeinc")#
abline(0, 1, col = 2)#
#
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))#
  qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
GiR_PP_Plots = function(Forward_stats, Backward_stats) {#
  nms = colnames(Forward_stats)#
  for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)#
      if (nrow(Forward_stats) > 10000) {#
       thinning2 = seq(from = floor(nrow(Forward_stats) / 10), to = nrow(Forward_stats), length.out = 10000)#
       Forward_test2 = Forward_stats[thinning2, i]#
       Backward_test2 = Backward_stats[thinning2, i]#
       } else {#
        Forward_test2 = Forward_stats[, i]#
        Backward_test2 = Backward_stats[, i]    	#
      }#
    text(paste("Backward Mean:", round(mean(Backward_stats[, i]), 4),#
                "\nForward Mean:", round(mean(Forward_stats[, i]), 4),#
                "\nt-test p-value:", round(t.test(Backward_test2, Forward_test2)$p.value, 4),#
                "\nMann-Whitney p-value:", round(wilcox.test(Backward_test2, Forward_test2)$p.value, 4)),#
                x = 0.65, y = 0.15, cex = 0.4)#
  }#
}
hi = quantile(c(timedist[,-1]), c(.025, .975 ))#
qqplot(c(timedist[,-1])[c(timedist[,-1])>=hi[1] & c(timedist[,-1])<=hi[2]], timeinc, xlab = "post", ylab = "obs", main = "timeinc")#
abline(0, 1, col = 2)#
#
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))#
  qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
for (i in 1:ncol(Forward_stats)) {#
    all = c(Backward_stats[, i], Forward_stats[, i])#
    quantiles = 1000#
    uniqueValues = quantile(all,seq(0, 1, length = quantiles))#
    qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(Forward_stats[, i] <= uniqueValues[j])#
  		qx2[j] = mean(Backward_stats[, i] <= uniqueValues[j])#
  	}#
    qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)
uniqueValues = quantile(c(timedist[,-1], timeinc), seq(0, 1, length = 1000))#
  qx1 = numeric(length(uniqueValues))#
  	qx2 = numeric(length(uniqueValues))#
  	for (j in 1:length(uniqueValues)) {#
  		qx1[j] = mean(c(timedist[,-1]) <= uniqueValues[j])#
  		qx2[j] = mean(c(timeinc) <= uniqueValues[j])#
  	}
qqplot(x = qx1,#
           y = qx2,#
           ylim = c(0, 1),#
           xlim = c(0, 1),#
           ylab = "Backward",#
           xlab = "Forward",#
           col = "blue",#
           pch = 19,#
           cex = 0.25,#
           main = nms[i],#
           cex.lab = 0.25,#
           cex.axis = 0.25,#
           cex.main = 0.5)#
    abline(0, 1, lty = 1, col = "red", lwd = 1)
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")#
lines(recipients, col = 2)
boxplot(recipientsdist[,-c(1:3)], ylim = c(0, 515),  main = "receiver size")#
lines(recipients[-c(1:3)], col = 2)
boxplot(recipientsdist[,-c(1:3)], ylim = c(0, 10),  main = "receiver size")#
lines(recipients[-c(1:3)], col = 2)
recipients
colMeans(recipientsdist)
length(colMeans(recipientsdist))
head(recipientsdist)
length(recipients)
boxplot(recipientsdist, ylim = c(0, 515),  main = "receiver size")
lines(recipients, col = 2)
boxplot(recipientsdist[,1:14], ylim = c(0, 515),  main = "receiver size")
lines(recipients[1:14], col = 2)
boxplot(recipientsdist[,1:14], ylim = c(0, 515),  main = "receiver size")#
lines(recipients[1:14], col = 2)
load('~/Desktop/Montgomery_infer.RData')
names(Montgomery_infer)
boxplot(recipientsdist[,1:14], ylim = c(0, 515),  main = "receiver size")#
lines(recipients[1:14], col = 2)
boxplot(recipientsdist[,-c(1:3)], ylim = c(0, 10),  main = "receiver size")#
lines(recipients[-c(1:3)], col = 2)
colMeans(Montgomery_infer$beta)
plot(Montgomery_infer$beta[,10], type = 'l')
plot(Montgomery_infer$beta[,11], type = 'l')
source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 11#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] > 0, sum(X[d,a,,4]), 0)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
dimnames(X)[[4]] = c("intercept", "outdegree", "indegree", "send", "receive", "2send", "2receive", "sibling", "cosibling", "Nreceive", "outdegree*Nrecieve")#
dimnames(Y)[[3]] = c("intercept", "female", "manager", "outdegree", "indegree", "weekend", "pm")
dimnames(Y)
save(Montgomery, file = "Montgomery.RData")
Montgomery = list(edge = edge, X = X, Y = Y, lasttime = email[min(trim-1), 21] - initialtime )
save(Montgomery, file = "Montgomery.RData")
getwd()
#install the package from Github#
library(devtools)#
install_github("desmarais-lab/MulticastNetwork/pkg")#
library(MulticastNetwork)#
#load our Montgomery county email data#
load("/Users/bomin8319/Box/gainlab_example/Bomin/Montgomery.RData")#
names(Montgomery)#
#
#data including sender a_d, reciever vector r_d, timestamp t_d#
edge = Montgomery$edge#
head(edge)#
#
#covariates affecting "who sends to whom"#
X = Montgomery$X#
head(X[100, 1, , ])#
X = X[,,,c(1:5)]    #use few covariates for this application#
#
#covariates affecting "when to send"#
Y = Montgomery$Y#
head(Y[100, , ])
Y = Y[,,,c(1:5)]    #use few covariates for this application#
P = dim(X)[4]#
Q = dim(Y)[3]
P
Q
Y = Y[,,c(1:5)]    #use few covariates for this application
Q = dim(Y)[3]
Q
prior.beta = list(mean = rep(0, P), var = 2*diag(P))#
prior.eta = list(mean = rep(0, Q), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
#
outer = 100#
inner = c(1, 1, 1)#
burn = 0#
#
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")#
names(Montgomery_infer)
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")
Inference
library(MulticastNetwork)
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")
install_github("desmarais-lab/MulticastNetwork/pkg")
Montgomery_infer = Inference(edge, X, Y, outer, inner, burn, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = Montgomery$lasttime, timedist = "lognormal")
library(MulticastNetwork)#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 11#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] > 0, sum(X[d,a,,4]), 0)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
Montgomery_infer = Inference(edge, X, Y, 55000, c(10,1,1), 15000, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.00001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, timedist = "lognormal")
Montgomery_infer = Inference(edge, X, Y, 55000, c(10,1,1), 15000, prior.beta, prior.eta, prior.sigma2, initialval = NULL,#
		  proposal.var = c(0.00001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, timedist = "exponential")
plot(Montgomery_infer$loglike, type = 'l')
plot(Montgomery_infer$sigma2, type = 'l')
plot(Montgomery_infer$beta[,1], type = 'l')
plot(Montgomery_infer$beta[,2], type = 'l')
plot(Montgomery_infer$beta[,3], type = 'l')
plot(Montgomery_infer$beta[,4], type = 'l')
plot(Montgomery_infer$beta[,5], type = 'l')
plot(Montgomery_infer$beta[,6], type = 'l')
plot(Montgomery_infer$beta[,7], type = 'l')
plot(Montgomery_infer$beta[,8], type = 'l')
plot(Montgomery_infer$beta[,9], type = 'l')
plot(Montgomery_infer$beta[,10], type = 'l')
plot(Montgomery_infer$beta[,11], type = 'l')
plot(Montgomery_infer$eta[,1], type = 'l')
plot(Montgomery_infer$eta[,2], type = 'l')
plot(Montgomery_infer$eta[,3], type = 'l')
plot(Montgomery_infer$eta[,4], type = 'l')
plot(Montgomery_infer$eta[,5], type = 'l')
plot(Montgomery_infer$eta[,6], type = 'l')
plot(Montgomery_infer$eta[,7], type = 'l')
plot(Montgomery_infer$eta[,8], type = 'l')
Montgomery_infer2 = Montgomery_infer
save(Montgomery_infer2, file = '/Users/bomin8319/Desktop/Montgomery_infer2.RData')
library(MulticastNetwork)
library(MulticastNetwork)#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 9#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10		#
		}#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]
set.seed(1)#
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)#
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
library(devtools)
setwd("/Users/bomin8319/Desktop/MulticastNetwork/pkg/R")
document()
check()
install()
library(Multicast)
library(MulticastNetwork)
PPE
load("/Users/bomin8319/Desktop/MulticastNetwork/Montgomery_infer.RData")
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)
initial
PPE
Montgomery_PPE = list()
n = 1
Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "lognormal")
P
#source("/Users/bomin8319/Desktop/MulticastNetwork/code/Multicast.R")#
library(MulticastNetwork)#
library(lubridate)#
load('~/Desktop/MulticastNetwork/code/Temporal_Email_Data.Rdata')#
Montgomery = Temporal_Email_Data$Montgomery#
email = Montgomery$email_data#
email = unique(email)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
email = email[order(email$timepoints), ]#
edge = list()#
initialtime =  as.numeric(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S")))#
for (d in 1:nrow(email)) {#
	t_d = email[d, 21] - initialtime#
	edge[[d]] = list(a_d = email[d,2], r_d = as.numeric(email[d,-c(1:2, 21)]), t_d = t_d)#
}#
#
uniqtime = unique(email$timepoints)#
# construct time covariates Y#
D = length(edge)#
A = length(Montgomery$manager_gender)#
Q = 7#
Y = array(1, dim = c(D,A,Q))#
for (a in 1:A) {#
	Y[,a,2] = 1* (Montgomery$manager_gender[a]=="Female")#
	Y[,a,3] = 1* (Montgomery$manager_department[a]=="County Manager")#
}#
timeunit = 3600#
Y[1,,6] = rep(as.numeric(wday(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
Y[1,,7] = rep(pm(as.POSIXct(strptime("01 Mar 2012 00:00:00", "%d %b %Y %H:%M:%S"))), A)#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	sent = email[index, 2]#
	received = email[index, 3:(2+A)]#
	Y[d, ,4] = tabulate(sent, A) #
	Y[d, ,5] = colSums(received)#
	Y[d,,6] = rep(as.numeric(wday(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S"))) %in% c(1, 7)), A)#
	Y[d,,7] = rep(as.numeric(pm(as.POSIXct(strptime(email[d-1,1], "%d %b %Y %H:%M:%S")))), A)#
}#
sendraw = function(data, a, r) {#
	sum(data[,2] == a & data[, 2+r]==1)#
}#
#
# construct recipient covariates X#
D = length(edge)#
A = length(Montgomery$manager_gender)#
P = 11#
X = array(0, dim = c(D,A,A,P))#
X[,,,1] = 1#
timeunit = 3600#
for (d in 2:D) {#
	index = which(email$timepoints >= uniqtime[which(uniqtime==email$timepoints[d])-1]-7*24*timeunit & email$timepoints < email$timepoints[d])#
	data = email[index, ]#
	sent = data[, 2]#
	received = data[, 3:(2+A)]#
	outdegree = tabulate(sent, A)#
	indegree = colSums(received)#
	for (a in 1:A) {#
		for (r in c(1:A)[-a]) {#
			X[d, a, r, 2] = outdegree[a]  #
			X[d, a, r, 3] = indegree[r]	#
			X[d, a, r, 4] = sendraw(data, a, r)#
			X[d, a, r, 5] = sendraw(data, r, a)#
			X[d, a, r, 6] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, h, r) / 10#
				}))#
			X[d, a, r, 7] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, r, h)#
				})) / 10#
			X[d, a, r, 8] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, h, a) * sendraw(data, h, r)#
				})) / 10#
			X[d, a, r, 9] = sum(sapply(c(1:A)[-c(a,r)], function(h) {#
				sendraw(data, a, h) * sendraw(data, r, h)#
				}))	/10	#
		}#
	  X[d, a, , 10] = ifelse(outdegree[a] > 0, sum(X[d,a,,4]), 0)#
	  X[d, a, , 11] = X[d, a, , 2] * X[d, a, , 10] / 10#
	}#
}#
#
prior.beta = list(mean = c(-3.5, rep(0, P-1)), var = 2*diag(P))#
prior.eta = list(mean = c(7, rep(0, Q-1)), var = 2*diag(Q))#
prior.sigma2 = list(a = 2, b = 1)#
email$timepoints =  as.numeric(as.POSIXct(strptime(email[,1], "%d %b %Y %H:%M:%S")))#
trim = which(email$timepoints >=7*24*timeunit+email$timepoints[1])#
edge = edge[trim]#
X = X[trim,,,]#
Y = Y[trim,,]#
#
set.seed(1)#
missing = list()#
missing[[1]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[1]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1#
missing[[2]] = matrix(0, nrow = dim(Y)[1], A)#
missing[[2]][sample(1:(dim(Y)[1]*A), 1118, replace = FALSE)] = 1#
missing[[3]] = matrix(0, nrow = dim(Y)[1], 1)#
missing[[3]][sample(1:dim(Y)[1], 62, replace = FALSE), ] = 1
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)
initial = list()#
initial$beta = colMeans(Montgomery_infer$beta)#
initial$eta =  colMeans(Montgomery_infer$eta)#
initial$u = Montgomery_infer$u#
initial$sigma2 = mean(Montgomery_infer$sigma2)#
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code/PPE")#
Montgomery_PPE = list()
n = 1
Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "lognormal")
names(Montgomery_PPE[[1]])
Montgomery_PPE[[1]]$senderpredict
Montgomery_PPE[[1]]$receiverpredict
names(Montgomery_PPE[[1]])
Montgomery_PPE[[1]]$receiverpredict
Montgomery_PPE[[1]]$receiverpredict[[1]]
dim(Montgomery_PPE[[1]]$receiverpredict)
Montgomery_PPE[[1]]$receiverpredict[1,]
Montgomery_PPE[[1]]$receiverpredict[,1]
setwd("/Users/bomin8319/Desktop/MulticastNetwork/pkg/R")
document()
install()
library(MulticastNetwork)
PPE
Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "lognormal")
Montgomery_PPE[[1]]$receiverpredict[,1]
Montgomery_PPE[[1]]$receiverpredict[,2]
Montgomery_PPE[[1]]$receiverpredict[1,]
Montgomery_PPE[[1]]$receiverpredict[100,]
Montgomery_PPE[[1]]$receiverpredict[1030,]
Montgomery_PPE[[1]]$receiverpredict[1050,]
Montgomery_PPE[[1]]$timepredict
length(Montgomery_PPE[[1]]$timepredict[1,])
length(unique(Montgomery_PPE[[1]]$timepredict[1,]))
plot(Montgomery_PPE[[1]]$timepredict[1,])
plot(Montgomery_PPE[[1]]$timepredict[1,], type = 'l')
plot(Montgomery_PPE[[1]]$timepredict[2], type = 'l')
plot(Montgomery_PPE[[1]]$timepredict[2,], type = 'l')
plot(Montgomery_PPE[[1]]$timepredict[3,], type = 'l')
setwd("/Users/bomin8319/Desktop/MulticastNetwork/code/PPE")#
Montgomery_PPE = list()#
for (n in 1:500) {#
	print(n)#
  Montgomery_PPE[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "lognormal")#
  filename = paste0("Montgomery_PPE", n,".RData")#
  save(Montgomery_PPE, file = filename)#
}
load("/Users/bomin8319/Desktop/MulticastNetwork/Montgomery_infer2.RData")
initial$beta
initial2 = list()#
initial2$beta = colMeans(Montgomery_infer2$beta)#
initial2$eta =  colMeans(Montgomery_infer2$eta)#
initial2$u = Montgomery_infer2$u#
initial2$sigma2 = mean(Montgomery_infer2$sigma2)
initial2$sigma2
initial2$beta
initial$eta
initial2$eta
Montgomery_PPE2 = list()#
for (n in 1:500) {#
	print(n)#
  Montgomery_PPE2[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial2, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "exponential")#
  filename = paste0("Montgomery_PPE2", n,"exp.RData")#
  save(Montgomery_PPE2, file = filename)#
}
initial2$u
load("/Users/bomin8319/Desktop/MulticastNetwork/Montgomery_infer2.RData")#
initial2 = list()#
initial2$beta = colMeans(Montgomery_infer2$beta)#
initial2$eta =  colMeans(Montgomery_infer2$eta)#
initial2$u = Montgomery_infer2$u#
initial2$sigma2 = mean(Montgomery_infer2$sigma2)#
#
Montgomery_PPE2 = list()#
for (n in 1:500) {#
	print(n)#
  Montgomery_PPE2[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial2, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "exponential")#
  filename = paste0("Montgomery_PPE2", n,"exp.RData")#
  save(Montgomery_PPE2, file = filename)#
}
setwd("/Users/bomin8319/Desktop/MulticastNetwork/pkg/R")
document()
install()
n
Montgomery_PPE2[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial2, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "exponential")
document()
check()
install()
Montgomery_PPE2[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial2, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "exponential")
install()
Montgomery_PPE2[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial2, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "exponential")
install()
Montgomery_PPE2[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial2, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "exponential")
senders[d]
d
d %in% sendermissing
Timepartindiv2(mu[d,], timeinc[d])
multinom_vec(exp(probi))
senders
exp(probi)
Q
install()
dexp
instalL()
install()
Montgomery_PPE2[[n]] = PPE(edge, missing, X, Y, 50, c(5,5,1), 0, prior.beta, prior.eta, prior.sigma2, initial = initial2, proposal.var = c(0.0001, 0.001, 0.1), timeunit = 3600, lasttime = email[min(trim-1), 21] - initialtime, MHprop.var = 0.1, timedist = "exponential")
Montgomery_PPE2[[n]]$senderpredict
Montgomery_PPE2[[n]]$timepredict
Montgomery_PPE[[n]]$timepredict
